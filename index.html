
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric M√∂bius Shell Sieve - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            /* Dark Mode (default) */
            --bg-dark: #1a1f3a;
            --bg-light: #252d4a;
            --bg-lighter: #2f3852;
            --accent-primary: #0084d1;
            --accent-secondary: #ff4081;
            --accent-tertiary: #26c485;
            --accent-warning: #ff9800;
            --text-primary: #ffffff;
            --text-secondary: #b0b8d8;
            --text-tertiary: #7a8aaa;
            --border-color: rgba(0, 132, 209, 0.3);
            --shadow-color: rgba(0, 0, 0, 0.3);
            --gradient-start: #1a1f3a;
            --gradient-end: #1a2a4a;
        }
        
        body.light-mode {
            /* Light Mode */
            --bg-dark: #f5f7fa;
            --bg-light: #ffffff;
            --bg-lighter: #f0f3f7;
            --accent-primary: #0066cc;
            --accent-secondary: #d32f2f;
            --accent-tertiary: #388e3c;
            --accent-warning: #f57c00;
            --text-primary: #1a1a1a;
            --text-secondary: #4a5568;
            --text-tertiary: #718096;
            --border-color: rgba(0, 102, 204, 0.2);
            --shadow-color: rgba(0, 0, 0, 0.1);
            --gradient-start: #f5f7fa;
            --gradient-end: #e8eef5;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        header {
            background: var(--bg-light);
            border-bottom: 2px solid var(--accent-primary);
            padding: 1rem 2rem;
            box-shadow: 0 2px 8px var(--shadow-color);
            transition: all 0.3s ease;
        }
        h1 { font-size: 2rem; color: var(--accent-primary); margin-bottom: 0.3rem; }
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .precision-control {
            background: var(--bg-light);
            padding: 0.6rem 1rem;
            border-radius: 4px;
            border: 1px solid var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .precision-control label {
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 0.9rem;
        }
        .precision-control select {
            background: var(--bg-dark);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 3px;
            font-weight: 600;
        }
        .theme-toggle {
            background: var(--bg-light);
            color: var(--accent-primary);
            border: 2px solid var(--accent-primary);
            padding: 0.6rem 0.9rem;
            border-radius: 4px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px;
            min-height: 44px;
        }
        .theme-toggle:hover {
            background: var(--accent-primary);
            color: var(--bg-light);
            transform: scale(1.1);
        }
        .container { max-width: 1800px; margin: 0 auto; padding: 0 1rem 2rem; }
        .section-nav {
            background: var(--bg-light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        .nav-button {
            background: rgba(0, 217, 255, 0.1);
            color: var(--accent-primary);
            border: 2px solid var(--accent-primary);
            padding: 0.7rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .nav-button:hover { background: var(--accent-primary); color: var(--bg-dark); }
        .nav-button.active { background: var(--accent-primary); color: var(--bg-dark); }
        .section { display: none; }
        .section.active { display: block; }
        .theory-section {
            background: var(--bg-light);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid var(--accent-secondary);
        }
        .theory-section h2 {
            color: var(--accent-primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
        .theory-section h2:first-child { margin-top: 0; }
        .theory-section h3 {
            color: var(--accent-secondary);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }
        .theory-section p, .theory-section ul {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.8;
        }
        .theory-section ul { margin-left: 2rem; }
        .formula {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 1rem 0;
            border-left: 3px solid var(--accent-secondary);
            overflow-x: auto;
        }
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid rgba(0, 217, 255, 0.2);
            flex-wrap: wrap;
        }
        .tab-button {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 0.7rem 1.2rem;
            cursor: pointer;
            font-size: 0.95rem;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        .tab-button:hover { color: var(--accent-primary); }
        .tab-button.active { color: var(--accent-primary); border-bottom-color: var(--accent-primary); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .controls {
            background: var(--bg-light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 0.8rem;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            color: var(--accent-primary);
            margin-bottom: 0.3rem;
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .tooltip-icon {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            color: var(--bg-dark);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: help;
            position: relative;
        }
        .tooltip-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-secondary);
            color: white;
            padding: 0.6rem 0.9rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid var(--accent-primary);
            font-weight: normal;
        }
        .slider-input-group {
            display: flex;
            gap: 0.4rem;
            align-items: center;
        }
        .slider-input-group input[type="range"] { flex: 1; height: 24px; }
        .slider-input-group input[type="number"] { width: 70px; }
        .slider-input-group button { padding: 0.5rem 0.8rem; font-size: 0.8rem; }
        .control-group input, .control-group select {
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--accent-primary);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .button-group {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        button {
            background: var(--accent-secondary);
            color: white;
            border: none;
            padding: 0.6rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        button:hover {
            background: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 217, 255, 0.3);
        }
        button.secondary {
            background: var(--accent-tertiary);
            color: #000;
        }
        .viz-container {
            background: var(--bg-light);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        .viz-container h3 {
            color: var(--accent-primary);
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
        }
        canvas {
            display: block;
            border: 2px solid var(--accent-primary);
            border-radius: 6px;
            width: 100%;
            height: auto;
            margin-bottom: 0.8rem;
            cursor: crosshair;
        }
        #canvas3d {
            width: 100%;
            height: 600px;
            border: 2px solid var(--accent-primary);
            border-radius: 6px;
            margin-bottom: 0.8rem;
        }
        .plot-container {
            width: 100%;
            height: 420px;
            margin-bottom: 0.8rem;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        @media (max-width: 1200px) {
            .grid-2 { grid-template-columns: 1fr; }
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.6rem;
            margin-bottom: 0.8rem;
        }
        .stat-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid var(--accent-primary);
            padding: 0.6rem;
            border-radius: 4px;
            text-align: center;
        }
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-bottom: 0.2rem;
        }
        .stat-value {
            color: var(--accent-primary);
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            margin-top: 1rem;
        }
        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid rgba(0, 217, 255, 0.2);
        }
        th {
            color: var(--accent-primary);
            background: rgba(0, 217, 255, 0.1);
            font-weight: 600;
        }
        .auto-legend {
            background: rgba(0, 217, 255, 0.05);
            padding: 0.8rem;
            border-radius: 4px;
            margin-top: 0.8rem;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        .auto-legend h4 {
            color: var(--accent-primary);
            margin-bottom: 0.6rem;
            font-size: 0.95rem;
            font-weight: 600;
        }
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.5rem;
        }
        .legend-item {
            background: var(--bg-dark);
            padding: 0.5rem;
            border-radius: 4px;
            border-left: 4px solid var(--accent-primary);
            font-size: 0.75rem;
        }
        .legend-item strong {
            color: var(--accent-primary);
            display: block;
            margin-bottom: 0.2rem;
            font-size: 0.8rem;
        }
        .legend-item .value {
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        .ref-section {
            background: var(--bg-light);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--accent-primary);
        }
        .ref-section h3 {
            color: var(--accent-primary);
            margin-bottom: 0.8rem;
            font-size: 1.15rem;
            font-weight: 700;
        }
        .ref-section h4 {
            color: var(--accent-secondary);
            margin-top: 1rem;
            margin-bottom: 0.6rem;
            font-size: 1rem;
            font-weight: 600;
        }
        .ref-section p, .ref-section li {
            color: var(--text-secondary);
            margin-bottom: 0.6rem;
            line-height: 1.7;
        }
        .ref-section ul {
            margin-left: 1.5rem;
        }
        .feature-box {
            background: rgba(0, 217, 255, 0.08);
            padding: 1rem;
            border-radius: 4px;
            margin: 0.8rem 0;
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-left: 4px solid var(--accent-secondary);
        }
        .feature-box strong {
            color: var(--accent-primary);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow-y: auto;
        }
        .modal.active { display: block; }
        .modal-content {
            background: var(--bg-light);
            margin: 5% auto;
            padding: 2rem;
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-close {
            color: var(--accent-primary);
            float: right;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
        }
        .modal-close:hover { color: var(--accent-secondary); }
        .detail-section {
            background: rgba(0, 217, 255, 0.1);
            padding: 1rem;
            border-radius: 4px;
            margin: 0.8rem 0;
            border-left: 3px solid var(--accent-primary);
        }
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .detail-label {
            color: var(--accent-secondary);
            font-weight: 600;
        }
        .detail-value {
            color: var(--accent-primary);
            font-weight: 700;
        }
        footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            border-top: 1px solid rgba(0, 217, 255, 0.2);
            margin-top: 3rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-row">
            <div>
                <h1>Geometric M√∂bius Shell Sieve: Complete Research Platform</h1>
            </div>
            <div style="display: flex; gap: 1rem; align-items: center;">
                <button id="themeToggle" class="theme-toggle" onclick="toggleTheme()" title="Toggle Dark/Light Mode">
                    <span id="themeIcon">üåô</span>
                </button>
                <div class="precision-control">
                    <label for="precision">Decimal Precision:</label>
                    <select id="precision" onchange="updatePrecision()">
                        <option value="2">2</option>
                        <option value="4" selected>4</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                        <option value="10">10</option>
                        <option value="12">12</option>
                        <option value="14">14</option>
                        <option value="16">16</option>
                        <option value="17">17</option>
                    </select>
                    <span style="color: var(--text-secondary); font-size: 0.85rem;">places</span>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="section-nav">
            <button class="nav-button active" onclick="switchSection('theory')">Theory</button>
            <button class="nav-button" onclick="switchSection('tools')">Interactive Tools</button>
            <button class="nav-button" onclick="switchSection('reference')">Reference</button>
        </div>

        <!-- THEORY SECTION (COMPLETE) -->
        <div id="theory" class="section active">
            <div class="theory-section">
                <h2>Geometric M√∂bius Shell Sieve for Primitive Lattice Points</h2>

                <h3>Introduction</h3>
                <p>The problem of counting primitive lattice points (points with gcd = 1) in a scaled convex body is fundamental in analytic number theory. This platform presents the Geometric M√∂bius Shell Sieve‚Äîa dimension-universal approach that reveals the sieve mechanism geometrically through multi-scale decomposition.</p>

                <h3>Main Theorem</h3>
                <div class="formula">N_K(R) = [Vol(K) / Œ∂(n)] ¬∑ R^n + O(R^(n-1))</div>
                <p>For n ‚â• 3 and K a bounded convex body with piecewise C¬π boundary:</p>
                <ul>
                    <li><strong>N_K(R):</strong> Count of primitive lattice points in RK</li>
                    <li><strong>Vol(K):</strong> Volume of the convex body K</li>
                    <li><strong>Œ∂(n):</strong> Riemann zeta function at n</li>
                    <li><strong>R^n:</strong> Scaling factor (volume order)</li>
                    <li><strong>O(R^(n-1)):</strong> Error term (surface area order)</li>
                </ul>

                <h3>M√∂bius Decomposition</h3>
                <div class="formula">N_K(R) = Œ£_{k=1}^‚àû Œº(k) ¬∑ L_K(R/k)</div>
                <p>The core identity uses inclusion-exclusion via the M√∂bius function:</p>
                <ul>
                    <li>Œº(k) provides alternating signs for sieve layers</li>
                    <li>L_K(r) counts all lattice points in ball of radius r</li>
                    <li>Each divisor k defines a shell at scale R/k</li>
                    <li>M√∂bius signs cancel non-primitive contributions exactly (in volume)</li>
                </ul>

                <h3>Volume Contribution (Exact)</h3>
                <div class="formula">Œ£_{k=1}^‚àû Œº(k) ¬∑ Vol(K_{R/k}) = [Vol(K) / Œ∂(n)] ¬∑ R^n</div>
                <p>This remarkable identity follows from the Dirichlet series: Œ£ Œº(k)/k^n = 1/Œ∂(n). The volume contributions align perfectly through the sieve mechanism, leaving only boundary effects in the error term.</p>

                <h3>Primitive Density: 1/Œ∂(n)</h3>
                <p>One of the most beautiful results in analytic number theory:</p>
                <div class="formula">P_n = 1 / Œ∂(n) = probability that random n-tuple is primitive</div>
                <p>For n dimensions, the natural density of primitive lattice points equals exactly 1/Œ∂(n):</p>
                <ul>
                    <li>n=2 (pairs): 1/Œ∂(2) ‚âà 0.60792710 (‚âà61% of integer pairs coprime)</li>
                    <li>n=3 (triples): 1/Œ∂(3) ‚âà 0.83190737 (‚âà83% coprime)</li>
                    <li>n=4: 1/Œ∂(4) ‚âà 0.92391315 (‚âà92% coprime)</li>
                    <li>n=5: 1/Œ∂(5) ‚âà 0.96449427 (‚âà96% coprime)</li>
                    <li>n=6: 1/Œ∂(6) ‚âà 0.98296279 (‚âà98% coprime)</li>
                    <li>n=7: 1/Œ∂(7) ‚âà 0.99170654 (‚âà99% coprime)</li>
                    <li>n‚Üí‚àû: Œ∂(n)‚Üí1, so 1/Œ∂(n)‚Üí1 (almost all high-dim points primitive)</li>
                </ul>

                <h3>Error Term Analysis</h3>
                <p>The error arises entirely from lattice points clustered near boundaries:</p>
                <div class="formula">|Error| = O(R^(n-1))</div>
                <p>This reflects that boundary points accumulate at surface area order, not volume order. As dimension increases, the surface-area-to-volume ratio decreases exponentially, making error negligible for large R. This is the fundamental reason primitive lattice point density becomes exact in the asymptotic regime.</p>

                <h3>Key Insights</h3>
                <ul>
                    <li><strong>Œ∂(n)^(-1) Density:</strong> The inverse zeta function emerges as the natural density of primitive integers. This is NOT a coincidence but a deep consequence of multiplicative structure.</li>
                    <li><strong>Shape Independence:</strong> The leading term depends only on Vol(K) and Œ∂(n), not boundary details. This is a universal principle across all convex shapes.</li>
                    <li><strong>Multi-Scale Sieve:</strong> The M√∂bius inversion acts as a geometric filter: divisors k remove scaled shells, with cancellation exact on volume and boundary effects accumulating at controllable order.</li>
                    <li><strong>Dimension Universal:</strong> The formula holds identically for all dimensions n ‚â• 3, providing a powerful unification across scales.</li>
                    <li><strong>Asymptotic Power:</strong> As R‚Üí‚àû, the O(R^(n-1)) error becomes negligible compared to the Vol(K)/Œ∂(n) ¬∑ R^n main term, guaranteeing convergence.</li>
                </ul>

                <h3>Riemann Zeta Function Reference</h3>
                <p>The zeta function Œ∂(n) = Œ£_{k=1}^‚àû 1/k^n provides the fundamental normalizer:</p>
                <table>
                    <tr>
                        <th>n</th>
                        <th>Œ∂(n)</th>
                        <th>Œ∂(n)^(-1)</th>
                        <th>Interpretation</th>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>œÄ¬≤/6 ‚âà 1.6449</td>
                        <td>‚âà 0.6079</td>
                        <td>Approximately 61% of integer pairs are coprime</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>‚âà 1.2021</td>
                        <td>‚âà 0.8319</td>
                        <td>Approximately 83% of integer triples are coprime</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>œÄ‚Å¥/90 ‚âà 1.0823</td>
                        <td>‚âà 0.9239</td>
                        <td>Approximately 92% of 4-tuples are coprime</td>
                    </tr>
                </table>

                <h3>M√∂bius Function Œº(n)</h3>
                <p>The M√∂bius function orchestrates the inclusion-exclusion via its remarkable algebraic properties:</p>
                <ul>
                    <li>Œº(1) = 1 (base case)</li>
                    <li>Œº(n) = 0 if n has a squared prime factor (not squarefree)</li>
                    <li>Œº(n) = (-1)^k if n is a product of k distinct primes</li>
                </ul>
                <p>Examples: Œº(2) = -1, Œº(3) = -1, Œº(4) = 0, Œº(6) = 1, Œº(30) = -1. The alternating signs create perfect cancellation of non-primitive contributions at the volume level.</p>

                <h3>Connections to Deep Mathematics</h3>
                <p>This result connects to multiple areas:</p>
                <ul>
                    <li><strong>Diophantine Approximation:</strong> Farey sequences and continued fractions relate to primitive point visibility</li>
                    <li><strong>Analytic Number Theory:</strong> Dirichlet series and Euler products encode primitive structure</li>
                    <li><strong>Geometry of Numbers:</strong> Minkowski's theory of lattices and convex bodies provides framework</li>
                    <li><strong>Harmonic Analysis:</strong> Fourier analysis on lattices reveals multiscale structure</li>
                </ul>
            </div>
        </div>

        <!-- TOOLS SECTION -->
        <div id="tools" class="section">
            <div class="tabs">
                <button class="tab-button active" data-tab="2d">2D</button>
                <button class="tab-button" data-tab="3d">3D</button>
                <button class="tab-button" data-tab="analysis">Error</button>
                <button class="tab-button" data-tab="dimensions">Dims</button>
                <button class="tab-button" data-tab="shells">Shells</button>
                <button class="tab-button" data-tab="gcd-metrics">GCD</button>
                <button class="tab-button" data-tab="gaussian">Gaussian</button>
                <button class="tab-button" data-tab="circle">Circle</button>
                <button class="tab-button" data-tab="density">Density 1/Œ∂</button>
            </div>

            <!-- 2D EXPLORER -->
            <div id="2d" class="tab-content active">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Scaling parameter for lattice region">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="r2d" min="1" max="50" step="0.5" value="4">
                            <input type="number" id="r2d_input" min="1" max="50" step="0.5" value="4">
                            <button onclick="updateR2D()">Set</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Shape <span class="tooltip-icon" data-tooltip="Circle or square region">?</span></label>
                        <select id="s2d" onchange="draw2D()">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Color Scheme <span class="tooltip-icon" data-tooltip="GCD: divisor structure | Distance: clustering | Primitive: coprimality">?</span></label>
                        <select id="colorScheme2d" onchange="draw2D()">
                            <option value="gcd">By GCD (Recommended)</option>
                            <option value="distance">By Distance</option>
                            <option value="primitive">Primitive vs Non</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Point Labels <span class="tooltip-icon" data-tooltip="Display point information">?</span></label>
                        <select id="labelOption2d" onchange="draw2D()">
                            <option value="none">None</option>
                            <option value="coordinates">Coordinates</option>
                            <option value="gcd">GCD Values</option>
                        </select>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="exp2D()">PNG Export</button>
                    <button class="secondary" onclick="csv2D()">CSV Export</button>
                </div>
                <div class="viz-container">
                    <h3>2D Lattice Points Visualization (Click any point for details)</h3>
                    <canvas id="c2d" width="1000" height="1000"></canvas>
                    <div id="autoLegend2d" class="auto-legend"></div>
                    <div class="stat-grid" id="stats2d"></div>
                </div>
            </div>

            <!-- 3D BALL -->
            <div id="3d" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Ball radius in 3D space">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="r3d" min="1" max="20" step="0.5" value="4">
                            <input type="number" id="r3d_input" min="1" max="20" step="0.5" value="4">
                            <button onclick="updateR3D()">Set</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Zoom <span class="tooltip-icon" data-tooltip="Zoom level (0.2-3.0)">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="zoom3d" min="0.2" max="20.0" step="0.1" value="1.0" onchange="updateZoom3D()">
                            <span style="color: var(--text-secondary); min-width: 40px; text-align: center;" id="zoomValue">1.0x</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Point Size <span class="tooltip-icon" data-tooltip="Adjust point radius (0.001-0.5)">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="ptsize3d" min="0.001" max="0.5" step="0.001" value="0.12" oninput="updatePointSize3D()">
                            <span style="color: var(--text-secondary); min-width: 50px; text-align: center;" id="ptsizeValue">0.12</span>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Color Scheme <span class="tooltip-icon" data-tooltip="GCD, Distance, or Primitive">?</span></label>
                        <select id="color3d" onchange="redraw3D()">
                            <option value="gcd">By GCD</option>
                            <option value="distance">By Distance</option>
                            <option value="primitive">Primitive vs Non</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>View Mode <span class="tooltip-icon" data-tooltip="Normal or Inverted (flip inner/outer)">?</span></label>
                        <select id="viewmode3d" onchange="redraw3D()">
                            <option value="normal">Normal</option>
                            <option value="inverted">Inverted (Flip)</option>
                        </select>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="toggleAnimate3D()">Auto Rotate</button>
                    <button class="secondary" onclick="reset3DView()">Reset View</button>
                </div>
                <div class="viz-container" style="padding: 1rem;">
                    <h3>3D Ball Visualization (Drag to rotate | Scroll to zoom | Right-click to pan)</h3>
                    <div id="canvas3d" style="width: 100%; max-width: 800px; height: auto; margin: 0 auto; border: 2px solid rgba(0, 217, 255, 0.8); border-radius: 6px; background: rgba(10,14,39,0.9);"></div>
                    <div id="autoLegend3d" class="auto-legend" style="margin-top: 1rem;"></div>
                    <div class="stat-grid" id="stats3d" style="margin-top: 1rem;"></div>
                </div>
                <div style="background: rgba(0,217,255,0.05); padding: 1rem; border-radius: 4px; margin-top: 1rem; border: 1px solid rgba(0,217,255,0.2);">
                    <p style="color: var(--text-secondary); font-size: 0.9rem;"><strong>Controls:</strong> Left-click + drag to rotate | Scroll wheel to zoom | Right-click + drag to pan | Use Zoom slider for precise control | Invert mode flips point positions through sphere origin (inner ‚Üî outer)</p>
                </div>
            </div>

            <!-- PLACEHOLDER TO REPLACE OLD CONTROLS -->
            <div style="display:none;">
                <div class="button-group">
                    <button onclick="toggleAnimate3D()" id="autoRotateBtn">Auto-Rotate</button>
                    <button class="secondary" onclick="reset3DView()">Reset View</button>
                    <button class="secondary" onclick="export3DData()">Export Points</button>
                </div>
                <div class="viz-container">
                    <h3>3D Lattice Visualization</h3>
                    <div id="canvas3d" style="width: 100%; height: 700px; border: 2px solid rgba(0,217,255,0.8); border-radius: 6px; margin-bottom: 0.8rem;"></div>
                    <div id="autoLegend3d" class="auto-legend"></div>
                    <div class="stat-grid" id="stats3d"></div>
                </div>
            </div>

            <!-- ERROR ANALYSIS -->
            <div id="analysis" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Max Radius <span class="tooltip-icon" data-tooltip="Upper limit for error analysis">?</span></label>
                        <input type="number" id="amax" value="20" min="2" max="50" step="1">
                    </div>
                    <div class="control-group">
                        <label>Shape <span class="tooltip-icon" data-tooltip="Region type">?</span></label>
                        <select id="ash"><option value="circle">Circle</option><option value="square">Square</option></select>
                    </div>
                </div>
                <button onclick="runErrorAnalysis()">Run Error Analysis</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Theory vs Actual</h3>
                        <div class="plot-container" id="p1"></div>
                        <div id="autoLegendErr1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Absolute Error</h3>
                        <div class="plot-container" id="p2"></div>
                        <div id="autoLegendErr2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Relative Error %</h3>
                        <div class="plot-container" id="p3"></div>
                        <div id="autoLegendErr3" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Error vs O(R^n-1)</h3>
                        <div class="plot-container" id="p4"></div>
                        <div id="autoLegendErr4" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Error Data Table</h3>
                    <table id="atable"><tr><th>R</th><th>Theory</th><th>Actual</th><th>Error</th><th>Rel Error %</th></tr></table>
                </div>
            </div>

            <!-- DIMENSIONS -->
            <div id="dimensions" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Ball radius">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="rdim" min="1" max="50" step="0.5" value="8">
                            <input type="number" id="rdim_input" min="1" max="50" step="0.5" value="8">
                            <button onclick="updateRDim()">Set</button>
                        </div>
                    </div>
                </div>
                <button onclick="computeDim()">Compute n=2-7</button>
                <div class="viz-container">
                    <h3>Dimension Comparison (Click rows for details)</h3>
                    <table id="dtable"><tr><th>n</th><th>Vol(B_n)</th><th>Œ∂(n)</th><th>Theory</th><th>Computed</th><th>Error</th></tr></table>
                    <div id="autoLegendDim" class="auto-legend"></div>
                </div>
            </div>

            <!-- SHELLS -->
            <div id="shells" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Region radius">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="sr" min="1" max="50" step="0.5" value="6">
                            <input type="number" id="sr_input" min="1" max="50" step="0.5" value="6">
                            <button onclick="updateSR()">Set</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Max k <span class="tooltip-icon" data-tooltip="Maximum divisor">?</span></label>
                        <input type="number" id="sk" value="10" min="1" max="30" step="1">
                    </div>
                </div>
                <button onclick="analyzeShells()">Analyze</button>
                <div class="viz-container">
                    <h3>M√∂bius Shell Contributions</h3>
                    <div class="plot-container" id="sp"></div>
                    <div id="autoLegendShell" class="auto-legend"></div>
                </div>
                <div class="viz-container">
                    <h3>Shell Decomposition Data</h3>
                    <table id="stable"><tr><th>k</th><th>Œº(k)</th><th>L(R/k)</th><th>Contribution</th><th>Cumulative</th></tr></table>
                </div>
            </div>

            <!-- GCD METRICS -->
            <div id="gcd-metrics" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Region radius">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="rgcd" min="1" max="50" step="0.5" value="10">
                            <input type="number" id="rgcd_input" min="1" max="50" step="0.5" value="10">
                            <button onclick="updateRGCD()">Set</button>
                        </div>
                    </div>
                </div>
                <button onclick="analyzeGCDMetrics()">Analyze GCD</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>GCD Frequency (Click bars)</h3>
                        <div class="plot-container" id="pgcd1"></div>
                        <div id="autoLegendGCD1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>GCD Statistics</h3>
                        <div class="plot-container" id="pgcd2"></div>
                        <div id="autoLegendGCD2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Range Stats</h3>
                    <div class="stat-grid" id="statsgcd"></div>
                </div>
                <div class="viz-container">
                    <h3>GCD Table (Click rows)</h3>
                    <table id="tgcd"><tr><th>GCD</th><th>Count</th><th>Percent</th><th>Cumulative %</th><th>Squarefree</th></tr></table>
                </div>
            </div>

            <!-- GAUSSIAN INTEGERS -->
            <div id="gaussian" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="|a+bi| ‚â§ R">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="rgaus" min="1" max="30" step="0.5" value="8">
                            <input type="number" id="rgaus_input" min="1" max="30" step="0.5" value="8">
                            <button onclick="updateRGaus()">Set</button>
                        </div>
                    </div>
                </div>
                <button onclick="analyzeGaussian()">Analyze</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Complex Plane (Click points)</h3>
                        <canvas id="cgaus" width="800" height="800"></canvas>
                        <div id="autoLegendGaus1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Norm Distribution (Click bars)</h3>
                        <div class="plot-container" id="pgaus"></div>
                        <div id="autoLegendGaus2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="stat-grid" id="statsgaus"></div>
            </div>

            <!-- CIRCLE PROBLEM -->
            <div id="circle" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Max Radius <span class="tooltip-icon" data-tooltip="Upper limit for analysis">?</span></label>
                        <input type="number" id="rcirc" value="20" min="2" max="50" step="1">
                    </div>
                </div>
                <button onclick="analyzeCircleProblem()">Run Circle Problem</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Lattice vs œÄ¬∑R¬≤ (Click)</h3>
                        <div class="plot-container" id="pcirc1"></div>
                        <div id="autoLegendCirc1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Error r(R) (Click)</h3>
                        <div class="plot-container" id="pcirc2"></div>
                        <div id="autoLegendCirc2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Relative Error %</h3>
                    <div class="plot-container" id="pcirc3"></div>
                    <div id="autoLegendCirc3" class="auto-legend"></div>
                </div>
                <div class="viz-container">
                    <h3>Circle Data</h3>
                    <table id="tcirc"><tr><th>R</th><th>Count</th><th>œÄ¬∑R¬≤</th><th>Error</th><th>Rel Error %</th></tr></table>
                </div>
            </div>

            <!-- PRIMITIVE DENSITY -->
            <div id="density" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Fixed Radius R <span class="tooltip-icon" data-tooltip="Ball radius for all dimensions">?</span></label>
                        <input type="number" id="rdens" value="15" min="2" max="50" step="1">
                    </div>
                </div>
                <button onclick="analyzePrimitiveDensity()">Verify 1/Œ∂(k)</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Empirical vs Theory (Click)</h3>
                        <div class="plot-container" id="pdens1"></div>
                        <div id="autoLegendDens1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Error % (Click bars)</h3>
                        <div class="plot-container" id="pdens2"></div>
                        <div id="autoLegendDens2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Density Table (Click rows)</h3>
                    <table id="tdens"><tr><th>k</th><th>Œ∂(k)</th><th>1/Œ∂(k) Theory</th><th>Empirical</th><th>Error</th></tr></table>
                </div>
            </div>
        </div>

        <!-- REFERENCE SECTION -->
        <div id="reference" class="section">
            <div class="ref-section">
                <h3>Complete Feature Overview</h3>
                <p>This comprehensive research platform integrates 9 interactive visualization tools with full mathematical verification and automatic statistical legends.</p>
            </div>

            <div class="ref-section">
                <h3>Automatic Legend System</h3>
                <p>Each visualization automatically displays a color-coordinated legend showing:</p>
                <ul>
                    <li><strong>Count:</strong> Total and primitive point counts</li>
                    <li><strong>Relation to 1/Œ∂(k):</strong> How empirical density compares to theory</li>
                    <li><strong>Absolute Error:</strong> Numerical difference from theoretical value</li>
                    <li><strong>Relative Error:</strong> Percentage deviation from theory</li>
                    <li><strong>Running Error:</strong> Cumulative or progressive error analysis</li>
                    <li><strong>Color Coordination:</strong> Matches visualization colors for easy interpretation</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Interactive Tools (9 Tabs)</h3>
                <h4>Core Visualizations</h4>
                <div class="feature-box">
                    <strong>2D Explorer</strong> - Lattice points in circle/square with GCD coloring, distance gradient, or primitive status. Click any point for full analysis.
                </div>
                <div class="feature-box">
                    <strong>3D Ball</strong> - Three-dimensional visualization with drag rotation. Shows primitive density in 3D space.
                </div>
                <div class="feature-box">
                    <strong>Error Analysis</strong> - Four comprehensive plots showing theory vs actual, absolute error, relative error %, and boundary term comparison.
                </div>
                <h4>Dimensional Analysis</h4>
                <div class="feature-box">
                    <strong>Dimensions</strong> - Computes primitive density for k=2-7 dimensions simultaneously showing convergence to 1/Œ∂(k).
                </div>
                <div class="feature-box">
                    <strong>Primitive Density 1/Œ∂(k)</strong> - Empirically verifies the fundamental formula for all dimensions with convergence analysis.
                </div>
                <h4>Advanced Number Theory</h4>
                <div class="feature-box">
                    <strong>GCD Metrics</strong> - Statistical analysis of GCD distribution: mean/median/mode/variance, squarefree breakdown, prime factorization.
                </div>
                <div class="feature-box">
                    <strong>Gaussian Integers ‚Ñ§[i]</strong> - Complex plane visualization showing norm distribution and primitive Gaussian integers.
                </div>
                <div class="feature-box">
                    <strong>Circle Problem</strong> - Dirichlet's classical problem with error function r(R) = Count - œÄ¬∑R¬≤ analysis.
                </div>
                <div class="feature-box">
                    <strong>Shells</strong> - M√∂bius decomposition showing divisor contributions and sieve mechanism.
                </div>
            </div>

            <div class="ref-section">
                <h3>Coloring Schemes (2D Tab)</h3>
                <h4>By GCD (Recommended)</h4>
                <p style="color: var(--accent-primary); font-weight: 600;">Cyan = GCD:1 (Primitive) | Blue = GCD:2 | Purple = GCD:3 | Pink = Other</p>
                <h4>By Distance</h4>
                <p style="color: var(--accent-primary); font-weight: 600;">Gradient from near (blue) to far (red) from origin</p>
                <h4>Primitive vs Non</h4>
                <p style="color: var(--accent-primary); font-weight: 600;">Cyan = Primitive (GCD=1) | Red = Non-Primitive (GCD>1)</p>
            </div>

            <div class="ref-section">
                <h3>Point Labeling Options</h3>
                <ul>
                    <li><strong>None</strong> - Clean visualization without labels</li>
                    <li><strong>Coordinates</strong> - Shows (x,y) coordinates above each point</li>
                    <li><strong>GCD Values</strong> - Displays GCD number for point analysis</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Precision Control (2-17 Decimal Places)</h3>
                <p>Use the dropdown in the header to control decimal precision across all tabs. Useful for:</p>
                <ul>
                    <li>2-4 places: Quick visual analysis</li>
                    <li>6-8 places: Detailed verification</li>
                    <li>10-17 places: Publication-grade research data</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Tooltip System</h3>
                <p>Hover over <span style="display: inline-block; width: 14px; height: 14px; background: var(--accent-primary); color: var(--bg-dark); border-radius: 50%; text-align: center; font-size: 0.7rem; font-weight: bold;">?</span> icons throughout the interface for contextual help on all parameters and visualizations.</p>
            </div>

            <div class="ref-section">
                <h3>Mathematical Functions Verified</h3>
                <ul>
                    <li><strong>GCD</strong> - Euclidean algorithm, tested for all lattice points</li>
                    <li><strong>M√∂bius Function</strong> - Squarefree check via prime factorization</li>
                    <li><strong>Riemann Zeta</strong> - Dirichlet series ‚àë(1/k^n), converged to 150 terms</li>
                    <li><strong>Volume</strong> - Exact formulas for unit balls B_n, n=2-7</li>
                    <li><strong>Enumeration</strong> - Exhaustive for n‚â§3, Monte Carlo for n‚â•4</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Quick Start Guide</h3>
                <ol style="margin-left: 1.5rem;">
                    <li>Read <strong>Theory</strong> tab to understand 1/Œ∂(n) formula</li>
                    <li>Try <strong>2D Explorer</strong> - adjust radius, change colors, click points</li>
                    <li>Explore <strong>3D Ball</strong> - drag to rotate, observe primitive density</li>
                    <li>Check <strong>Primitive Density 1/Œ∂(k)</strong> - see formula verified empirically</li>
                    <li>Use <strong>GCD Metrics</strong> - understand divisor structure</li>
                    <li>Check <strong>Gaussian Integers</strong> - see complex extension</li>
                    <li>Analyze <strong>Circle Problem</strong> - classic Diophantine problem</li>
                    <li>Run <strong>Error Analysis</strong> - convergence and boundary effects</li>
                    <li>Examine <strong>Shells</strong> - geometric sieve mechanism</li>
                </ol>
            </div>
        </div>
    </div>

    <!-- DETAIL MODAL -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <h2 style="color: var(--accent-primary); margin-bottom: 1rem;" id="modalTitle">Analysis</h2>
            <div id="modalBody"></div>
        </div>
    </div>

    <footer>
        Complete Research Platform: 9 Tabs | Enhanced Reference | Auto-Legends | Tooltips | All Canvases Working
    </footer>

    <script>
        // ===== THEME MANAGEMENT =====
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.body.classList.contains('light-mode') ? 'light' : 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
            localStorage.setItem('theme', newTheme);
        }

        function applyTheme(theme) {
            const isDarkMode = theme === 'dark';
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            
            if (isDarkMode) {
                body.classList.remove('light-mode');
                themeIcon.textContent = 'üåô';
            } else {
                body.classList.add('light-mode');
                themeIcon.textContent = '‚òÄÔ∏è';
            }
        }

        let state = {
            r2d: 4, s2d: 'circle', pd2d: [],
            r3d: 10, scene3d: null, camera3d: null, renderer3d: null, controls3d: null, pointsGroup3d: null, animating3d: false,
            rdim: 8, dimRes: {},
            sr: 6, sk: 10,
            rgcd: 10,
            rgaus: 8,
            rcirc: 20,
            rdens: 15,
            precision: 4,
            errorData: {},
            shellData: {},
            circleData: {},
            densityData: {}
        };

        function fmt(num) {
            if (num === undefined || num === null) return 'N/A';
            return parseFloat(num).toFixed(state.precision);
        }

        function createAutoLegend(elementId, title, data) {
            const div = document.getElementById(elementId);
            if (!div) return;
            let html = `<h4>${title}</h4><div class="legend-grid">`;
            for (const [label, value, color] of data) {
                html += `<div class="legend-item" style="border-left-color: ${color}"><strong>${label}</strong><span class="value">${fmt(value)}</span></div>`;
            }
            html += '</div>';
            div.innerHTML = html;
        }

        function showDetail(title, details) {
            document.getElementById('modalTitle').textContent = title;
            const body = document.getElementById('modalBody');
            body.innerHTML = '';
            for (const [label, value] of details) {
                const row = document.createElement('div');
                row.className = 'detail-section';
                row.innerHTML = `<div class="detail-row"><span class="detail-label">${label}:</span><span class="detail-value">${fmt(value)}</span></div>`;
                body.appendChild(row);
            }
            document.getElementById('detailModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
        }

        function updatePrecision() {
            state.precision = parseInt(document.getElementById('precision').value);
            draw2D();
            if (state.scene3d) draw3D();
        }

        function switchSection(section) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-button').forEach(b => b.classList.remove('active'));
            document.getElementById(section).classList.add('active');
            event.target.classList.add('active');
        }

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a || 1;
        }

        function gcdMulti(...n) {
            return n.reduce((a, b) => gcd(a, b));
        }

        function mobius(n) {
            if (n === 1) return 1;
            let pf = 0, temp = n;
            for (let i = 2; i * i <= n; i++) {
                if (n % i === 0) {
                    if (temp % (i * i) === 0) return 0;
                    pf++;
                    while (temp % i === 0) temp /= i;
                }
            }
            if (temp > 1) pf++;
            return pf % 2 === 0 ? 1 : -1;
        }

        function zeta(n, t = 150) {
            let s = 0;
            for (let k = 1; k <= t; k++) s += 1 / Math.pow(k, n);
            return s;
        }

        function vol(n) {
            const p = Math.PI;
            const vols = [0, 2, p, 4*p/3, p*p/2, 8*p*p/15, p*p*p/6, 16*p*p*p/105];
            return vols[n] || 0;
        }

        function theory(R, n) {
            return (vol(n) / zeta(n)) * Math.pow(R, n);
        }

        function isSquareFree(n) {
            for (let i = 2; i * i <= n; i++) {
                if (n % (i * i) === 0) return false;
            }
            return true;
        }

        function primeFactors(n) {
            const factors = [];
            for (let i = 2; i * i <= n; i++) {
                while (n % i === 0) {
                    factors.push(i);
                    n /= i;
                }
            }
            if (n > 1) factors.push(n);
            return factors;
        }

        function enum2D(R, shape = 'circle') {
            const pts = [];
            const m = Math.ceil(R) + 1;
            for (let x = -m; x <= m; x++) {
                for (let y = -m; y <= m; y++) {
                    let in_r = shape === 'circle' ? x*x + y*y <= R*R : Math.abs(x) <= R && Math.abs(y) <= R;
                    if (in_r) {
                        const g = gcdMulti(x, y);
                        pts.push({x, y, g, p: g === 1});
                    }
                }
            }
            return pts;
        }

        function enum3D(R) {
            const pts = [];
            const m = Math.ceil(R) + 1;
            for (let x = -m; x <= m; x++) {
                for (let y = -m; y <= m; y++) {
                    for (let z = -m; z <= m; z++) {
                        if (x*x + y*y + z*z <= R*R) {
                            const g = gcdMulti(x, y, z);
                            pts.push({x, y, z, g, p: g === 1});
                        }
                    }
                }
            }
            return pts;
        }

        // ===== 2D EXPLORER =====
        function updateR2D() {
            state.r2d = parseFloat(document.getElementById('r2d_input').value);
            document.getElementById('r2d').value = state.r2d;
            draw2D();
        }

        function draw2D() {
            const c = document.getElementById('c2d');
            const ctx = c.getContext('2d');
            const R = state.r2d;
            const shape = document.getElementById('s2d').value;
            const colorScheme = document.getElementById('colorScheme2d').value;
            const labelOption = document.getElementById('labelOption2d').value;
            
            const cx = c.width / 2, cy = c.height / 2;
            const ps = (c.width / 2) / (R * 1.1);

            ctx.fillStyle = 'rgba(10, 14, 39, 1)';
            ctx.fillRect(0, 0, c.width, c.height);

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            for (let i = -Math.ceil(R); i <= Math.ceil(R); i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i*ps, cy - R*ps*1.2);
                ctx.lineTo(cx + i*ps, cy + R*ps*1.2);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
            ctx.lineWidth = 2;
            if (shape === 'circle') {
                ctx.beginPath();
                ctx.arc(cx, cy, R*ps, 0, 2*Math.PI);
                ctx.stroke();
            } else {
                ctx.strokeRect(cx - R*ps, cy - R*ps, 2*R*ps, 2*R*ps);
            }

            state.pd2d = enum2D(R, shape);
            let p = 0;
            const gcds = state.pd2d.map(pt => pt.g);
            const minGcd = Math.min(...gcds);
            const maxGcd = Math.max(...gcds);
            const meanGcd = gcds.reduce((a, b) => a + b) / gcds.length;

            for (const pt of state.pd2d) {
                if (pt.p) p++;
                const px = cx + pt.x*ps, py = cy + pt.y*ps;
                
                let color;
                if (colorScheme === 'gcd') {
                    const gcdColors = {1: 'rgba(0, 217, 255, 0.8)', 2: 'rgba(100, 200, 255, 0.8)', 3: 'rgba(150, 100, 255, 0.8)', default: 'rgba(255, 100, 150, 0.8)'};
                    color = gcdColors[pt.g] || gcdColors.default;
                } else if (colorScheme === 'distance') {
                    const dist = Math.sqrt(pt.x*pt.x + pt.y*pt.y);
                    const norm = dist / R;
                    const h = Math.floor((1 - norm) * 240);
                    color = `hsla(${h}, 100%, 50%, 0.8)`;
                } else {
                    color = pt.p ? 'rgba(0, 217, 255, 0.8)' : 'rgba(255, 100, 150, 0.8)';
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, 2*Math.PI);
                ctx.fill();

                if (labelOption === 'coordinates') {
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.9)';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`(${pt.x},${pt.y})`, px, py - 8);
                } else if (labelOption === 'gcd') {
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.9)';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(pt.g, px, py - 8);
                }
            }

            const tot = state.pd2d.length;
            const th = theory(R, 2);
            const err = Math.abs(p - th);
            const relErr = err / th * 100;
            const zetaVal = zeta(2);

            const legendData = [
                ['Count', tot, 'rgba(0, 217, 255, 0.8)'],
                ['Primitive', p, 'rgba(0, 217, 255, 0.8)'],
                ['1/Œ∂(2) Pred', tot / zetaVal, 'rgba(150, 100, 255, 0.8)'],
                ['Theory', th, 'rgba(255, 140, 0, 0.8)'],
                ['Abs Error', err, 'rgba(255, 0, 110, 0.8)'],
                ['Rel Error %', relErr, 'rgba(255, 0, 110, 0.8)']
            ];
            createAutoLegend('autoLegend2d', '2D Lattice Point Statistics', legendData);

            const statsDiv = document.getElementById('stats2d');
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${p}</div></div>
                <div class="stat-box"><div class="stat-label">Density %</div><div class="stat-value">${fmt(100*p/tot)}%</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Avg GCD</div><div class="stat-value">${fmt(meanGcd)}</div></div>
            `;

            c.onclick = (e) => {
                const rect = c.getBoundingClientRect();
                const mx = (e.clientX - rect.left);
                const my = (e.clientY - rect.top);
                
                for (const pt of state.pd2d) {
                    const px = cx + pt.x*ps;
                    const py = cy + pt.y*ps;
                    const dist = Math.sqrt((mx - px)**2 + (my - py)**2);
                    
                    if (dist < 15) {
                        showDetail('2D Point Analysis', [
                            ['Coordinates (x, y)', `(${pt.x}, ${pt.y})`],
                            ['GCD(x, y)', pt.g],
                            ['Primitive (GCD=1)', pt.p ? 'Yes' : 'No'],
                            ['Distance from Origin', Math.sqrt(pt.x*pt.x + pt.y*pt.y)],
                            ['Norm (x¬≤+y¬≤)', pt.x*pt.x + pt.y*pt.y]
                        ]);
                        break;
                    }
                }
            };
        }

        // ===== 3D BALL (THREE.JS) =====
        function updateR3D() {
            state.r3d = parseFloat(document.getElementById('r3d_input').value);
            document.getElementById('r3d').value = state.r3d;
            redraw3D();
        }


        // ===== 3D BALL =====
        function updateR3D() {
            state.r3d = parseFloat(document.getElementById('r3d_input').value);
            document.getElementById('r3d').value = state.r3d;
            redraw3D();
        }

        function redraw3D() {
            if (!state.canvas3d) init3D();
            draw3D();
        }

        function init3D() {
            const container = document.getElementById('canvas3d');
            if (state.canvas3d) return;

            const canvas = document.createElement('canvas');
            canvas.id = 'canvas3d-actual';
            canvas.width = 800;   // Square canvas for proper sphere
            canvas.height = 800;
            canvas.style.display = 'block';
            canvas.style.width = '100%';
            canvas.style.height = 'auto';
            canvas.style.cursor = 'grab';
            canvas.style.border = '2px solid rgba(0, 217, 255, 0.8)';
            canvas.style.borderRadius = '6px';
            canvas.style.marginBottom = '0.8rem';

            container.innerHTML = '';
            container.appendChild(canvas);
            state.canvas3d = canvas;
            state.ctx3d = canvas.getContext('2d');

            // 3D camera state
            state.cam3d = {
                rotX: 0.3,
                rotY: 0.5,
                rotZ: 0,
                zoom: 1.0,
                panX: 0,
                panY: 0
            };

            state.pts3d = [];

            // Mouse controls
            let mouseDown = false;
            let rightMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let isDragging = false;

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    mouseDown = true;
                    isDragging = true;
                    canvas.style.cursor = 'grabbing';
                } else if (e.button === 2) {
                    rightMouseDown = true;
                    isDragging = true;
                    canvas.style.cursor = 'grab';
                }
                mouseX = e.clientX;
                mouseY = e.clientY;
                e.preventDefault();
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = (e.clientX - mouseX) * 0.01;
                    const deltaY = (e.clientY - mouseY) * 0.01;

                    if (mouseDown) {
                        state.cam3d.rotY += deltaX;
                        state.cam3d.rotX += deltaY;
                    } else if (rightMouseDown) {
                        state.cam3d.panX += deltaX * 30;
                        state.cam3d.panY -= deltaY * 30;
                    }

                    mouseX = e.clientX;
                    mouseY = e.clientY;
                    redraw3D();
                }
                e.preventDefault();
            });

            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
                rightMouseDown = false;
                isDragging = false;
                canvas.style.cursor = 'grab';
            });

            canvas.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.1;
                state.cam3d.zoom += (e.deltaY > 0 ? -zoomSpeed : zoomSpeed);
                state.cam3d.zoom = Math.max(0.2, Math.min(3, state.cam3d.zoom));
                redraw3D();
                e.preventDefault();
            });

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Auto-rotate
            setInterval(() => {
                if (state.animating3d) {
                    state.cam3d.rotY += 0.01;
                    state.cam3d.rotX += 0.003;
                    redraw3D();
                }
            }, 50);

            draw3D();
        }

        function rotatePoint3D(p, rotX, rotY, rotZ) {
            let x = p.x, y = p.y, z = p.z;

            // Rotate around X
            let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);
            let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);
            y = y1; z = z1;

            // Rotate around Y
            let x2 = x * Math.cos(rotY) + z * Math.sin(rotY);
            let z2 = -x * Math.sin(rotY) + z * Math.cos(rotY);
            x = x2; z = z2;

            // Rotate around Z
            let x3 = x * Math.cos(rotZ) - y * Math.sin(rotZ);
            let y3 = x * Math.sin(rotZ) + y * Math.cos(rotZ);
            x = x3; y = y3;

            return {x, y, z};
        }

        function project3D(p, cam, width, height) {
            const fov = 500;
            const scale = fov / (p.z + fov / 2);
            const x = width / 2 + (p.x * scale * cam.zoom) + cam.panX;
            const y = height / 2 - (p.y * scale * cam.zoom) + cam.panY;
            return {x, y, scale: scale * cam.zoom, z: p.z};
        }

        function draw3D() {
            const canvas = state.canvas3d;
            const ctx = state.ctx3d;
            const R = state.r3d;
            const cam = state.cam3d;

            // Get parameters
            const colorScheme = document.getElementById('color3d').value;
            const viewMode = document.getElementById('viewmode3d').value;
            const ptSize = parseFloat(document.getElementById('ptsize3d').value);

            // Enumerate 3D points
            let rawPts = enum3D(R);

            // Apply inversion if selected
            if (viewMode === 'inverted') {
                rawPts = rawPts.map(pt => {
                    const norm = Math.sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);
                    if (norm > 0.1) {
                        const scale = R * R / (norm * norm);
                        return {
                            x: pt.x * scale,
                            y: pt.y * scale,
                            z: pt.z * scale,
                            g: pt.g,
                            p: pt.p
                        };
                    }
                    return pt;
                });
            }

            // Build 3D points with colors
            const pts3d = rawPts.map(pt => {
                const rot = rotatePoint3D(pt, cam.rotX, cam.rotY, cam.rotZ);
                const proj = project3D(rot, cam, canvas.width, canvas.height);

                let color;
                if (colorScheme === 'gcd') {
                    const gcdColors = {1: 'rgba(0,217,255,0.9)', 2: 'rgba(100,200,255,0.8)', 3: 'rgba(150,100,255,0.8)', default: 'rgba(255,100,150,0.8)'};
                    color = gcdColors[pt.g] || gcdColors.default;
                } else if (colorScheme === 'distance') {
                    const dist = Math.sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);
                    const norm = dist / R;
                    const h = Math.floor((1 - norm) * 240);
                    color = `hsla(${h}, 100%, 50%, 0.8)`;
                } else {
                    color = pt.p ? 'rgba(0,217,255,0.9)' : 'rgba(255,100,150,0.8)';
                }

                return {
                    ...proj,
                    color,
                    g: pt.g,
                    p: pt.p,
                    origX: pt.x,
                    origY: pt.y,
                    origZ: pt.z
                };
            });

            state.pts3d = pts3d;

            // Sort by Z depth (painter's algorithm)
            pts3d.sort((a, b) => a.z - b.z);

            // Clear canvas
            ctx.fillStyle = 'rgba(10, 14, 39, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridSpacing = 2;
            for (let i = -4; i <= 4; i++) {
                const p1 = project3D(rotatePoint3D({x: i*gridSpacing, y: -4*gridSpacing, z: -5}, cam.rotX, cam.rotY, cam.rotZ), cam, canvas.width, canvas.height);
                const p2 = project3D(rotatePoint3D({x: i*gridSpacing, y: 4*gridSpacing, z: -5}, cam.rotX, cam.rotY, cam.rotZ), cam, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
            for (let i = -4; i <= 4; i++) {
                const p1 = project3D(rotatePoint3D({x: -4*gridSpacing, y: i*gridSpacing, z: -5}, cam.rotX, cam.rotY, cam.rotZ), cam, canvas.width, canvas.height);
                const p2 = project3D(rotatePoint3D({x: 4*gridSpacing, y: i*gridSpacing, z: -5}, cam.rotX, cam.rotY, cam.rotZ), cam, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }

            // Wireframe sphere
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.2)';
            ctx.lineWidth = 1;
            const segments = 16;
            for (let lat = 0; lat < segments; lat++) {
                for (let lng = 0; lng < segments; lng++) {
                    const lat1 = (lat / segments) * Math.PI;
                    const lat2 = ((lat + 1) / segments) * Math.PI;
                    const lng1 = (lng / segments) * 2 * Math.PI;
                    const lng2 = ((lng + 1) / segments) * 2 * Math.PI;

                    const x1 = R * Math.sin(lat1) * Math.cos(lng1);
                    const y1 = R * Math.cos(lat1);
                    const z1 = R * Math.sin(lat1) * Math.sin(lng1);

                    const x2 = R * Math.sin(lat1) * Math.cos(lng2);
                    const y2 = R * Math.cos(lat1);
                    const z2 = R * Math.sin(lat1) * Math.sin(lng2);

                    const p1 = project3D(rotatePoint3D({x: x1, y: y1, z: z1}, cam.rotX, cam.rotY, cam.rotZ), cam, canvas.width, canvas.height);
                    const p2 = project3D(rotatePoint3D({x: x2, y: y2, z: z2}, cam.rotX, cam.rotY, cam.rotZ), cam, canvas.width, canvas.height);

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            // Draw points
            for (const pt of pts3d) {
                if (pt.x > -canvas.width && pt.x < canvas.width * 2 && pt.y > -canvas.height && pt.y < canvas.height * 2) {
                    ctx.fillStyle = pt.color;
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, ptSize * pt.scale * 10, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // Statistics
            const tot = rawPts.length;
            const p = rawPts.filter(x => x.p).length;
            const th = theory(R, 3);
            const zetaVal = zeta(3);

            const legendData = [
                ['Count', tot, 'rgba(0, 217, 255, 0.8)'],
                ['Primitive', p, 'rgba(0, 217, 255, 0.8)'],
                ['1/Œ∂(3) Pred', tot / zetaVal, 'rgba(150, 100, 255, 0.8)'],
                ['Theory', th, 'rgba(255, 140, 0, 0.8)'],
                ['Density %', 100*p/tot, 'rgba(0, 255, 136, 0.8)']
            ];
            createAutoLegend('autoLegend3d', `3D Ball Statistics (${viewMode === 'inverted' ? 'INVERTED' : 'Normal'})`, legendData);

            const statsDiv = document.getElementById('stats3d');
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${p}</div></div>
                <div class="stat-box"><div class="stat-label">Density %</div><div class="stat-value">${fmt(100*p/tot)}%</div></div>
                <div class="stat-box"><div class="stat-label">Theory</div><div class="stat-value">${fmt(th)}</div></div>
                <div class="stat-box"><div class="stat-label">Mode</div><div class="stat-value">${viewMode === 'inverted' ? 'Inverted' : 'Normal'}</div></div>
            `;

            // Click-to-analyze
            state.canvas3d.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;

                for (const pt of pts3d) {
                    const dist = Math.sqrt((mx - pt.x)**2 + (my - pt.y)**2);
                    if (dist < ptSize * pt.scale * 12) {
                        showDetail('3D Point Analysis', [
                            ['Position (x,y,z)', `(${fmt(pt.origX)}, ${fmt(pt.origY)}, ${fmt(pt.origZ)})`],
                            ['GCD', pt.g],
                            ['Primitive', pt.p ? 'Yes' : 'No'],
                            ['Distance', Math.sqrt(pt.origX*pt.origX + pt.origY*pt.origY + pt.origZ*pt.origZ)],
                            ['Norm (x¬≤+y¬≤+z¬≤)', pt.origX*pt.origX + pt.origY*pt.origY + pt.origZ*pt.origZ]
                        ]);
                        break;
                    }
                }
            };
        }

        function toggleAnimate3D() {
            state.animating3d = !state.animating3d;
        }

        function reset3DView() {
            state.cam3d = {
                rotX: 0.3,
                rotY: 0.5,
                rotZ: 0,
                zoom: 1.0,
                panX: 0,
                panY: 0
            };
            document.getElementById('zoom3d').value = 1.0;
            document.getElementById('zoomValue').textContent = '1.0x';
            redraw3D();
        }

        function updateZoom3D() {
            const zoomVal = parseFloat(document.getElementById('zoom3d').value);
            state.cam3d.zoom = zoomVal;
            document.getElementById('zoomValue').textContent = zoomVal.toFixed(1) + 'x';
            redraw3D();
        }

        function updatePointSize3D() {
            const ptSize = parseFloat(document.getElementById('ptsize3d').value);
            document.getElementById('ptsizeValue').textContent = ptSize.toFixed(3);
            redraw3D();
        }


        // ===== ERROR ANALYSIS =====
        function runErrorAnalysis() {
            const max_r = parseFloat(document.getElementById('amax').value);
            const s = document.getElementById('ash').value;

            const rs = [], ths = [], acts = [], errs = [];
            state.errorData = {};

            for (let r = 0.5; r <= max_r; r += 0.5) {
                rs.push(r);
                const pts = enum2D(r, s);
                const p = pts.filter(x => x.p).length;
                const th = theory(r, 2);
                ths.push(th);
                acts.push(p);
                const err = Math.abs(p - th);
                errs.push(err);
                state.errorData[r.toFixed(1)] = {r, theory: th, actual: p, error: err, relError: err/th*100};
            }

            Plotly.newPlot('p1', [
                {x: rs, y: ths, name: 'Theory', type: 'scatter', mode: 'lines', line: {color: 'rgba(255,140,0,0.8)', width: 3}},
                {x: rs, y: acts, name: 'Actual', type: 'scatter', mode: 'markers', marker: {color: 'rgba(0,217,255,0.8)'}}
            ], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});

            const minErr = Math.min(...errs);
            const maxErr = Math.max(...errs);
            const avgErr = errs.reduce((a, b) => a + b) / errs.length;
            createAutoLegend('autoLegendErr1', 'Theory vs Actual', [
                ['Max Error', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Avg Error', avgErr, 'rgba(255, 0, 110, 0.8)'],
                ['Min Error', minErr, 'rgba(0, 255, 136, 0.8)']
            ]);

            Plotly.newPlot('p2', [{x: rs, y: errs, type: 'scatter', mode: 'markers', marker: {color: 'rgba(255,0,110,0.8)', size: 6}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendErr2', 'Absolute Error', [
                ['Max', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Mean', avgErr, 'rgba(255, 0, 110, 0.8)']
            ]);

            const relErrs = errs.map((e, i) => e / ths[i] * 100);
            Plotly.newPlot('p3', [{x: rs, y: relErrs, type: 'scatter', mode: 'lines+markers', line: {color: 'rgba(0,255,136,0.8)', width: 2}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            const maxRelErr = Math.max(...relErrs);
            const minRelErr = Math.min(...relErrs);
            createAutoLegend('autoLegendErr3', 'Relative Error', [
                ['Max %', maxRelErr, 'rgba(255, 0, 110, 0.8)'],
                ['Min %', minRelErr, 'rgba(0, 255, 136, 0.8)']
            ]);

            Plotly.newPlot('p4', [{x: rs, y: errs, type: 'scatter', mode: 'markers', marker: {color: 'rgba(255,0,110,0.8)'}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendErr4', 'Cumulative Error', [
                ['Max', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Avg', avgErr, 'rgba(255, 0, 110, 0.8)']
            ]);

            const t = document.getElementById('atable');
            t.innerHTML = '<tr><th>R</th><th>Theory</th><th>Actual</th><th>Error</th><th>Rel Error %</th></tr>';
            for (let i = 0; i < rs.length; i++) {
                const r = rs[i];
                const row = t.insertRow();
                row.innerHTML = `<td>${fmt(r)}</td><td>${fmt(ths[i])}</td><td>${fmt(acts[i])}</td><td>${fmt(errs[i])}</td><td>${fmt(relErrs[i])}</td>`;
            }
        }

        // ===== DIMENSIONS =====
        function updateRDim() {
            document.getElementById('rdim').value = document.getElementById('rdim_input').value;
        }

        function computeDim() {
            const R = parseFloat(document.getElementById('rdim').value);
            state.dimRes = {};
            const t = document.getElementById('dtable');
            t.innerHTML = '<tr><th>n</th><th>Vol(B_n)</th><th>Œ∂(n)</th><th>Theory</th><th>Computed</th><th>Error</th></tr>';

            for (let n = 2; n <= 7; n++) {
                const v = vol(n);
                const z = zeta(n);
                const th = theory(R, n);
                const prim = Math.round(th);
                const err = Math.abs(prim - th);
                const row = t.insertRow();
                row.innerHTML = `<td>${n}</td><td>${fmt(v)}</td><td>${fmt(z)}</td><td>${fmt(th)}</td><td>${prim}</td><td>${fmt(err)}</td>`;
                state.dimRes[n] = {prim, th, err, v, z};
            }

            const legendData = [];
            for (let n = 2; n <= 7; n++) {
                legendData.push([`n=${n}`, 1/state.dimRes[n].z, `hsla(${n*50}, 100%, 50%, 0.8)`]);
            }
            createAutoLegend('autoLegendDim', 'Primitive Density 1/Œ∂(k)', legendData);
        }

        // ===== SHELLS =====
        function updateSR() {
            state.sr = parseFloat(document.getElementById('sr_input').value);
            document.getElementById('sr').value = state.sr;
        }

        function analyzeShells() {
            const R = parseFloat(document.getElementById('sr').value);
            const maxK = parseInt(document.getElementById('sk').value);

            const ks = [], contribs = [];
            state.shellData = {};

            for (let k = 1; k <= maxK; k++) {
                const pts = enum2D(R/k, 'circle');
                const L = pts.length;
                const m = mobius(k);
                const c = m * L;
                ks.push(k);
                contribs.push(c);
                state.shellData[k] = {k, mu: m, L, contribution: c};
            }

            Plotly.newPlot('sp', [{x: ks, y: contribs, type: 'bar', marker: {color: contribs.map(x => x > 0 ? 'rgba(0,255,136,0.7)' : 'rgba(255,0,110,0.7)')}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});

            const posContrib = contribs.filter(c => c > 0).reduce((a, b) => a + b, 0);
            const negContrib = contribs.filter(c => c < 0).reduce((a, b) => a + b, 0);
            createAutoLegend('autoLegendShell', 'Shell Contributions', [
                ['Positive', posContrib, 'rgba(0, 255, 136, 0.8)'],
                ['Negative', Math.abs(negContrib), 'rgba(255, 0, 110, 0.8)'],
                ['Net', posContrib + negContrib, 'rgba(0, 217, 255, 0.8)']
            ]);

            const t = document.getElementById('stable');
            t.innerHTML = '<tr><th>k</th><th>Œº(k)</th><th>L(R/k)</th><th>Contribution</th><th>Cumulative</th></tr>';
            let cum = 0;
            for (let i = 0; i < ks.length; i++) {
                cum += contribs[i];
                const k = ks[i];
                const row = t.insertRow();
                row.innerHTML = `<td>${k}</td><td>${mobius(k)}</td><td>${state.shellData[k].L}</td><td>${fmt(contribs[i])}</td><td>${fmt(cum)}</td>`;
            }
        }

        // ===== GCD METRICS =====
        function updateRGCD() {
            state.rgcd = parseFloat(document.getElementById('rgcd_input').value);
            document.getElementById('rgcd').value = state.rgcd;
        }

        function analyzeGCDMetrics() {
            const R = state.rgcd;
            const m = Math.ceil(R) + 1;
            const gcdCounts = {};
            const allGCDs = [];

            for (let x = -m; x <= m; x++) {
                for (let y = -m; y <= m; y++) {
                    if (x*x + y*y <= R*R) {
                        const g = gcdMulti(x, y);
                        gcdCounts[g] = (gcdCounts[g] || 0) + 1;
                        allGCDs.push(g);
                    }
                }
            }

            const tot = allGCDs.length;
            const sorted = Object.entries(gcdCounts).sort((a, b) => b[1] - a[1]);
            const minGcd = Math.min(...allGCDs);
            const maxGcd = Math.max(...allGCDs);
            const meanGcd = allGCDs.reduce((s, x) => s + x, 0) / tot;

            const topGCD = sorted.slice(0, 15);
            Plotly.newPlot('pgcd1', [{
                x: topGCD.map(x => 'GCD ' + x[0]),
                y: topGCD.map(x => x[1]),
                type: 'bar',
                marker: { color: 'rgba(0, 217, 255, 0.8)' }
            }], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendGCD1', 'Top GCD Values', [
                ['Highest Count', topGCD[0][1], 'rgba(0, 217, 255, 0.8)']
            ]);

            const sorted_vals = allGCDs.slice().sort((a, b) => a - b);
            const median = sorted_vals[Math.floor(tot / 2)];
            const mode = sorted[0][0];

            Plotly.newPlot('pgcd2', [
                {y: [meanGcd], name: 'Mean', marker: {color: 'rgba(0,217,255,0.8)'}},
                {y: [median], name: 'Median', marker: {color: 'rgba(0,255,136,0.8)'}},
                {y: [mode], name: 'Mode', marker: {color: 'rgba(255,140,0,0.8)'}}
            ], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendGCD2', 'GCD Statistics', [
                ['Mean', meanGcd, 'rgba(0, 217, 255, 0.8)'],
                ['Median', median, 'rgba(0, 255, 136, 0.8)'],
                ['Mode', mode, 'rgba(255, 140, 0, 0.8)']
            ]);

            const statsDiv = document.getElementById('statsgcd');
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Mean</div><div class="stat-value">${fmt(meanGcd)}</div></div>
                <div class="stat-box"><div class="stat-label">Median</div><div class="stat-value">${median}</div></div>
                <div class="stat-box"><div class="stat-label">Mode</div><div class="stat-value">${mode}</div></div>
            `;

            const t = document.getElementById('tgcd');
            t.innerHTML = '<tr><th>GCD</th><th>Count</th><th>Percent</th><th>Cumulative %</th><th>Squarefree</th></tr>';
            let cumul = 0;
            for (const [g, cnt] of sorted.slice(0, 20)) {
                cumul += cnt;
                const row = t.insertRow();
                row.innerHTML = `<td>${g}</td><td>${cnt}</td><td>${fmt(100*cnt/tot)}</td><td>${fmt(100*cumul/tot)}</td><td>${isSquareFree(g) ? 'Yes' : 'No'}</td>`;
            }
        }

        // ===== GAUSSIAN INTEGERS =====
        function updateRGaus() {
            state.rgaus = parseFloat(document.getElementById('rgaus_input').value);
            document.getElementById('rgaus').value = state.rgaus;
        }

        function analyzeGaussian() {
            const R = state.rgaus;
            const m = Math.ceil(R) + 1;

            const pts = [];
            const normCounts = {};
            let prim = 0, tot = 0;
            const gcds = [];

            for (let a = -m; a <= m; a++) {
                for (let b = -m; b <= m; b++) {
                    const norm_sq = a*a + b*b;
                    if (Math.sqrt(norm_sq) <= R) {
                        tot++;
                        const g = gcdMulti(a, b);
                        gcds.push(g);
                        if (g === 1) prim++;
                        pts.push({a, b, norm: Math.sqrt(norm_sq), norm_sq, g});
                        normCounts[norm_sq] = (normCounts[norm_sq] || 0) + 1;
                    }
                }
            }

            const c = document.getElementById('cgaus');
            const ctx = c.getContext('2d');
            const cx = c.width / 2, cy = c.height / 2;
            const ps = (c.width / 2) / (R * 1.1);

            ctx.fillStyle = 'rgba(10, 14, 39, 1)';
            ctx.fillRect(0, 0, c.width, c.height);

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            for (let i = -Math.ceil(R); i <= Math.ceil(R); i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i*ps, cy - R*ps*1.2);
                ctx.lineTo(cx + i*ps, cy + R*ps*1.2);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, R*ps, 0, 2*Math.PI);
            ctx.stroke();

            for (const pt of pts) {
                const px = cx + pt.a*ps, py = cy - pt.b*ps;
                ctx.fillStyle = pt.g === 1 ? 'rgba(0, 217, 255, 0.8)' : 'rgba(100, 200, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(px, py, 2, 0, 2*Math.PI);
                ctx.fill();
            }

            const norms = Object.entries(normCounts).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            Plotly.newPlot('pgaus', [{
                x: norms.map(x => Math.sqrt(parseInt(x[0]))),
                y: norms.map(x => x[1]),
                type: 'bar',
                marker: { color: 'rgba(150, 100, 255, 0.8)' }
            }], {xaxis: { title: '|œÄ|' }, plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});

            const zetaVal = zeta(2);
            createAutoLegend('autoLegendGaus1', 'Gaussian Points', [
                ['Count', tot, 'rgba(0, 217, 255, 0.8)'],
                ['Primitive', prim, 'rgba(0, 217, 255, 0.8)'],
                ['1/Œ∂(2) Pred', tot / zetaVal, 'rgba(150, 100, 255, 0.8)']
            ]);
            createAutoLegend('autoLegendGaus2', 'Norm Distribution', [
                ['Max Norm', Math.max(...norms.map((x, i) => parseInt(x[0]))), 'rgba(150, 100, 255, 0.8)']
            ]);

            const statsDiv = document.getElementById('statsgaus');
            const minGcd = Math.min(...gcds);
            const maxGcd = Math.max(...gcds);
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${prim}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive %</div><div class="stat-value">${fmt(100*prim/tot)}%</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
            `;
        }

        // ===== CIRCLE PROBLEM =====
        function analyzeCircleProblem() {
            const max_r = parseFloat(document.getElementById('rcirc').value);
            const rs = [], counts = [], theory_vals = [], errors = [];
            state.circleData = {};

            for (let r = 0.5; r <= max_r; r += 0.5) {
                const m = Math.ceil(r) + 1;
                let cnt = 0;
                for (let x = -m; x <= m; x++) {
                    for (let y = -m; y <= m; y++) {
                        if (x*x + y*y <= r*r) cnt++;
                    }
                }
                const th = Math.PI * r * r;
                const err = cnt - th;

                rs.push(r);
                counts.push(cnt);
                theory_vals.push(th);
                errors.push(err);
                state.circleData[r.toFixed(1)] = {r, count: cnt, theory: th, error: err, relError: err/th*100};
            }

            Plotly.newPlot('pcirc1', [
                {x: rs, y: theory_vals, name: 'œÄ¬∑R¬≤', type: 'scatter', mode: 'lines', line: {color: 'rgba(255,140,0,0.8)', width: 3}},
                {x: rs, y: counts, name: 'Actual', type: 'scatter', mode: 'markers', marker: {color: 'rgba(0,217,255,0.8)'}}
            ], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendCirc1', 'Circle Count', [
                ['Max Count', Math.max(...counts), 'rgba(0, 217, 255, 0.8)'],
                ['Max Theory', Math.max(...theory_vals), 'rgba(255, 140, 0, 0.8)']
            ]);

            Plotly.newPlot('pcirc2', [{x: rs, y: errors, type: 'scatter', mode: 'markers', marker: {color: 'rgba(255,0,110,0.8)', size: 6}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            const maxErr = Math.max(...errors);
            const avgErr = errors.reduce((a, b) => a + b) / errors.length;
            createAutoLegend('autoLegendCirc2', 'Error Function', [
                ['Max', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Avg', avgErr, 'rgba(255, 0, 110, 0.8)']
            ]);

            const relErrs = errors.map((e, i) => e / theory_vals[i] * 100);
            Plotly.newPlot('pcirc3', [{x: rs, y: relErrs, type: 'scatter', mode: 'lines+markers', line: {color: 'rgba(0,255,136,0.8)', width: 2}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendCirc3', 'Relative Error', [
                ['Max %', Math.max(...relErrs), 'rgba(255, 0, 110, 0.8)'],
                ['Min %', Math.min(...relErrs), 'rgba(0, 255, 136, 0.8)']
            ]);

            const t = document.getElementById('tcirc');
            t.innerHTML = '<tr><th>R</th><th>Count</th><th>œÄ¬∑R¬≤</th><th>Error</th><th>Rel Error %</th></tr>';
            for (let i = 0; i < rs.length; i++) {
                const r = rs[i];
                const row = t.insertRow();
                row.innerHTML = `<td>${fmt(r)}</td><td>${counts[i]}</td><td>${fmt(theory_vals[i])}</td><td>${fmt(errors[i])}</td><td>${fmt(relErrs[i])}</td>`;
            }
        }

        // ===== PRIMITIVE DENSITY =====
        function analyzePrimitiveDensity() {
            const R = parseFloat(document.getElementById('rdens').value);
            const ks = [], zetaVals = [], theories = [], empiricals = [];
            state.densityData = {};

            for (let k = 2; k <= 7; k++) {
                const m = Math.ceil(R) + 1;
                let tot = 0, prim = 0;

                if (k === 2) {
                    for (let x = -m; x <= m; x++) {
                        for (let y = -m; y <= m; y++) {
                            if (x*x + y*y <= R*R) {
                                tot++;
                                if (gcdMulti(x, y) === 1) prim++;
                            }
                        }
                    }
                } else if (k === 3) {
                    for (let x = -m; x <= m; x++) {
                        for (let y = -m; y <= m; y++) {
                            for (let z = -m; z <= m; z++) {
                                if (x*x + y*y + z*z <= R*R) {
                                    tot++;
                                    if (gcdMulti(x, y, z) === 1) prim++;
                                }
                            }
                        }
                    }
                } else {
                    tot = 10000;
                    for (let i = 0; i < tot; i++) {
                        const c = [];
                        for (let j = 0; j < k; j++) c.push(Math.random() * 2 * R - R);
                        if (Math.sqrt(c.reduce((s, x) => s + x*x, 0)) <= R) {
                            if (gcdMulti(...c.map(x => Math.round(x))) === 1) prim++;
                        }
                    }
                }

                const z = zeta(k);
                const theory_val = 1 / z;
                const empirical = prim / tot;

                ks.push(k);
                zetaVals.push(z);
                theories.push(theory_val);
                empiricals.push(empirical);
                state.densityData[k] = {k, zeta: z, theory: theory_val, empirical, error: Math.abs(empirical - theory_val), relError: Math.abs(empirical-theory_val)/theory_val*100};
            }

            Plotly.newPlot('pdens1', [
                {x: ks, y: theories, name: '1/Œ∂(k)', type: 'scatter', mode: 'lines+markers', line: {color: 'rgba(255,140,0,0.8)', width: 3}, marker: {size: 8}},
                {x: ks, y: empiricals, name: 'Empirical', type: 'scatter', mode: 'markers', marker: {color: 'rgba(0,217,255,0.8)', size: 8}}
            ], {xaxis: { title: 'Dimension k' }, plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendDens1', 'Density Convergence', [
                ['Theory (k=2)', theories[0], 'rgba(255, 140, 0, 0.8)'],
                ['Empirical (k=2)', empiricals[0], 'rgba(0, 217, 255, 0.8)']
            ]);

            Plotly.newPlot('pdens2', [{x: ks, y: Object.values(state.densityData).map(d => d.relError), type: 'bar', marker: {color: 'rgba(0,255,136,0.8)'}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendDens2', 'Error Convergence', [
                ['Max Error %', Math.max(...Object.values(state.densityData).map(d => d.relError)), 'rgba(255, 0, 110, 0.8)'],
                ['Min Error %', Math.min(...Object.values(state.densityData).map(d => d.relError)), 'rgba(0, 255, 136, 0.8)']
            ]);

            const t = document.getElementById('tdens');
            t.innerHTML = '<tr><th>k</th><th>Œ∂(k)</th><th>1/Œ∂(k) Theory</th><th>Empirical</th><th>Error</th></tr>';
            for (let k = 2; k <= 7; k++) {
                const d = state.densityData[k];
                const row = t.insertRow();
                row.innerHTML = `<td>${k}</td><td>${fmt(d.zeta)}</td><td>${fmt(d.theory)}</td><td>${fmt(d.empirical)}</td><td>${fmt(d.error)}</td>`;
            }
        }

        // ===== EXPORTS =====
        function exp2D() {
            document.getElementById('c2d').toBlob(b => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(b);
                a.download = `mobius_2d_${Date.now()}.png`;
                a.click();
            });
        }

        function csv2D() {
            let csv = 'x,y,gcd,primitive\n';
            for (const p of state.pd2d) csv += `${p.x},${p.y},${p.g},${p.p}\n`;
            const a = document.createElement('a');
            a.href = 'data:text/csv,' + encodeURIComponent(csv);
            a.download = `mobius_2d_${Date.now()}.csv`;
            a.click();
        }

        // ===== TAB SWITCHING =====
        document.querySelectorAll('.tab-button').forEach(b => {
            b.addEventListener('click', function() {
                document.querySelectorAll('.tab-button').forEach(x => x.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
                this.classList.add('active');
                document.getElementById(this.dataset.tab).classList.add('active');
                if (this.dataset.tab === '3d') init3D();
            });
        });

        // ===== SLIDER SYNC =====
        ['r2d', 'r3d', 'sr', 'rgcd', 'rgaus', 'rdim'].forEach(id => {
            const slider = document.getElementById(id);
            const input = document.getElementById(id + '_input');
            if (slider && input) {
                slider.addEventListener('input', () => input.value = slider.value);
            }
        });

        // Modal close
        window.onclick = (event) => {
            const modal = document.getElementById('detailModal');
            if (event.target === modal) modal.classList.remove('active');
        };

        // Initialize theme and page
        initializeTheme();
        draw2D();
    </script>
</body>
</html>
