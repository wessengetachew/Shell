
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Möbius Shell Sieve - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-dark: #0a0e27;
            --bg-light: #1a1f3a;
            --accent-primary: #00d9ff;
            --accent-secondary: #ff006e;
            --accent-tertiary: #00ff88;
            --text-primary: #e0e0ff;
            --text-secondary: #a0a8d8;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #141829 100%);
            color: var(--text-primary);
            line-height: 1.6;
        }
        header {
            background: rgba(10, 14, 39, 0.95);
            border-bottom: 3px solid var(--accent-primary);
            padding: 1rem 2rem;
        }
        h1 { font-size: 2rem; color: var(--accent-primary); margin-bottom: 0.3rem; }
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .precision-control {
            background: var(--bg-light);
            padding: 0.6rem 1rem;
            border-radius: 4px;
            border: 1px solid var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .precision-control label {
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 0.9rem;
        }
        .precision-control select {
            background: var(--bg-dark);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 3px;
            font-weight: 600;
        }
        .container { max-width: 1800px; margin: 0 auto; padding: 0 1rem 2rem; }
        .section-nav {
            background: var(--bg-light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        .nav-button {
            background: rgba(0, 217, 255, 0.1);
            color: var(--accent-primary);
            border: 2px solid var(--accent-primary);
            padding: 0.7rem 1.2rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
        }
        .nav-button:hover { background: var(--accent-primary); color: var(--bg-dark); }
        .nav-button.active { background: var(--accent-primary); color: var(--bg-dark); }
        .section { display: none; }
        .section.active { display: block; }
        .theory-section {
            background: var(--bg-light);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border-left: 4px solid var(--accent-secondary);
        }
        .theory-section h2 {
            color: var(--accent-primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }
        .theory-section h2:first-child { margin-top: 0; }
        .theory-section h3 {
            color: var(--accent-secondary);
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }
        .theory-section p, .theory-section ul {
            color: var(--text-secondary);
            margin-bottom: 1rem;
            line-height: 1.8;
        }
        .theory-section ul { margin-left: 2rem; }
        .formula {
            background: rgba(0, 0, 0, 0.4);
            padding: 1rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            margin: 1rem 0;
            border-left: 3px solid var(--accent-secondary);
            overflow-x: auto;
        }
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid rgba(0, 217, 255, 0.2);
            flex-wrap: wrap;
        }
        .tab-button {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 0.7rem 1.2rem;
            cursor: pointer;
            font-size: 0.95rem;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        .tab-button:hover { color: var(--accent-primary); }
        .tab-button.active { color: var(--accent-primary); border-bottom-color: var(--accent-primary); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .controls {
            background: var(--bg-light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 0.8rem;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .control-group label {
            color: var(--accent-primary);
            margin-bottom: 0.3rem;
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .tooltip-icon {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            color: var(--bg-dark);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: help;
            position: relative;
        }
        .tooltip-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-secondary);
            color: white;
            padding: 0.5rem 0.8rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid var(--accent-primary);
        }
        .slider-input-group {
            display: flex;
            gap: 0.4rem;
            align-items: center;
        }
        .slider-input-group input[type="range"] { flex: 1; height: 24px; }
        .slider-input-group input[type="number"] { width: 70px; }
        .slider-input-group button { padding: 0.5rem 0.8rem; font-size: 0.8rem; }
        .control-group input, .control-group select {
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 2px solid var(--accent-primary);
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .button-group {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        button {
            background: var(--accent-secondary);
            color: white;
            border: none;
            padding: 0.6rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        button:hover {
            background: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 217, 255, 0.3);
        }
        button.secondary {
            background: var(--accent-tertiary);
            color: #000;
        }
        .viz-container {
            background: var(--bg-light);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        .viz-container h3 {
            color: var(--accent-primary);
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
        }
        canvas {
            display: block;
            border: 2px solid var(--accent-primary);
            border-radius: 6px;
            width: 100%;
            height: auto;
            margin-bottom: 0.8rem;
            cursor: crosshair;
        }
        #canvas3d {
            width: 100%;
            height: 600px;
            border: 2px solid var(--accent-primary);
            border-radius: 6px;
            margin-bottom: 0.8rem;
        }
        .plot-container {
            width: 100%;
            height: 420px;
            margin-bottom: 0.8rem;
        }
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        @media (max-width: 1200px) {
            .grid-2 { grid-template-columns: 1fr; }
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.6rem;
            margin-bottom: 0.8rem;
        }
        .stat-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid var(--accent-primary);
            padding: 0.6rem;
            border-radius: 4px;
            text-align: center;
        }
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-bottom: 0.2rem;
        }
        .stat-value {
            color: var(--accent-primary);
            font-size: 1.2rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            margin-top: 1rem;
        }
        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid rgba(0, 217, 255, 0.2);
        }
        th {
            color: var(--accent-primary);
            background: rgba(0, 217, 255, 0.1);
            font-weight: 600;
        }
        .auto-legend {
            background: rgba(0, 217, 255, 0.05);
            padding: 1rem;
            border-radius: 4px;
            margin-top: 0.8rem;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }
        .auto-legend h4 {
            color: var(--accent-primary);
            margin-bottom: 0.6rem;
            font-size: 0.95rem;
        }
        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 0.6rem;
        }
        .legend-item {
            background: var(--bg-dark);
            padding: 0.6rem;
            border-radius: 4px;
            border-left: 3px solid var(--accent-primary);
            font-size: 0.8rem;
        }
        .legend-item strong {
            color: var(--accent-primary);
            display: block;
            margin-bottom: 0.3rem;
        }
        .legend-item .value {
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            overflow-y: auto;
        }
        .modal.active { display: block; }
        .modal-content {
            background: var(--bg-light);
            margin: 5% auto;
            padding: 2rem;
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal-close {
            color: var(--accent-primary);
            float: right;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
        }
        .modal-close:hover { color: var(--accent-secondary); }
        .detail-section {
            background: rgba(0, 217, 255, 0.1);
            padding: 1rem;
            border-radius: 4px;
            margin: 0.8rem 0;
            border-left: 3px solid var(--accent-primary);
        }
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        .detail-label {
            color: var(--accent-secondary);
            font-weight: 600;
        }
        .detail-value {
            color: var(--accent-primary);
            font-weight: 700;
        }
        .ref-section {
            background: var(--bg-light);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--accent-primary);
        }
        .ref-section h3 {
            color: var(--accent-primary);
            margin-bottom: 0.8rem;
            font-size: 1.1rem;
        }
        .ref-section h4 {
            color: var(--accent-secondary);
            margin-top: 0.8rem;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        .ref-section p, .ref-section li {
            color: var(--text-secondary);
            margin-bottom: 0.6rem;
            line-height: 1.6;
        }
        .ref-section ul {
            margin-left: 1.5rem;
        }
        .feature-box {
            background: rgba(0, 217, 255, 0.1);
            padding: 1rem;
            border-radius: 4px;
            margin: 0.8rem 0;
            border: 1px solid var(--accent-primary);
        }
        footer {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
            border-top: 1px solid rgba(0, 217, 255, 0.2);
            margin-top: 3rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-row">
            <div>
                <h1>Geometric Möbius Shell Sieve: Complete Research Platform</h1>
            </div>
            <div class="precision-control">
                <label for="precision">Decimal Precision:</label>
                <select id="precision" onchange="updatePrecision()">
                    <option value="2">2</option>
                    <option value="4" selected>4</option>
                    <option value="6">6</option>
                    <option value="8">8</option>
                    <option value="10">10</option>
                    <option value="12">12</option>
                    <option value="14">14</option>
                    <option value="16">16</option>
                    <option value="17">17</option>
                </select>
                <span style="color: var(--text-secondary); font-size: 0.85rem;">places</span>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="section-nav">
            <button class="nav-button active" onclick="switchSection('theory')">Theory</button>
            <button class="nav-button" onclick="switchSection('tools')">Interactive Tools</button>
            <button class="nav-button" onclick="switchSection('reference')">Reference</button>
        </div>

        <!-- THEORY SECTION -->
        <div id="theory" class="section active">
            <div class="theory-section">
                <h2>Geometric Möbius Shell Sieve for Primitive Lattice Points</h2>
                <h3>Introduction</h3>
                <p>The problem of counting primitive lattice points (points with gcd = 1) in a scaled convex body is fundamental in analytic number theory. This platform presents the Geometric Möbius Shell Sieve—a dimension-universal approach that reveals the sieve mechanism geometrically through multi-scale decomposition.</p>
                <h3>Main Theorem</h3>
                <div class="formula">N_K(R) = [Vol(K) / ζ(n)] · R^n + O(R^(n-1))</div>
                <p>For n ≥ 3 and K a bounded convex body with piecewise C¹ boundary:</p>
                <ul>
                    <li><strong>N_K(R):</strong> Count of primitive lattice points in RK</li>
                    <li><strong>Vol(K):</strong> Volume of the convex body K</li>
                    <li><strong>ζ(n):</strong> Riemann zeta function at n</li>
                    <li><strong>R^n:</strong> Scaling factor (volume order)</li>
                    <li><strong>O(R^(n-1)):</strong> Error term (surface area order)</li>
                </ul>
                <h3>Primitive Density: 1/ζ(n)</h3>
                <div class="formula">P_n = 1 / ζ(n) = probability that random n-tuple is primitive</div>
                <ul>
                    <li>n=2: 1/ζ(2) ≈ 0.60792710 (≈61% of pairs coprime)</li>
                    <li>n=3: 1/ζ(3) ≈ 0.83190737 (≈83% coprime)</li>
                    <li>n=4: 1/ζ(4) ≈ 0.92391315 (≈92% coprime)</li>
                    <li>n≥5: Density rapidly approaches 1 (almost all coprime)</li>
                </ul>
            </div>
        </div>

        <!-- TOOLS SECTION -->
        <div id="tools" class="section">
            <div class="tabs">
                <button class="tab-button active" data-tab="2d">2D</button>
                <button class="tab-button" data-tab="3d">3D</button>
                <button class="tab-button" data-tab="analysis">Error</button>
                <button class="tab-button" data-tab="dimensions">Dims</button>
                <button class="tab-button" data-tab="shells">Shells</button>
                <button class="tab-button" data-tab="gcd-metrics">GCD</button>
                <button class="tab-button" data-tab="gaussian">Gaussian</button>
                <button class="tab-button" data-tab="circle">Circle</button>
                <button class="tab-button" data-tab="density">Density 1/ζ</button>
            </div>

            <!-- 2D EXPLORER -->
            <div id="2d" class="tab-content active">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Scaling parameter for lattice region">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="r2d" min="1" max="50" step="0.5" value="4">
                            <input type="number" id="r2d_input" min="1" max="50" step="0.5" value="4">
                            <button onclick="updateR2D()">Set</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Shape <span class="tooltip-icon" data-tooltip="Region type: circle or square">?</span></label>
                        <select id="s2d" onchange="draw2D()">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Color Scheme <span class="tooltip-icon" data-tooltip="Visualization method for points">?</span></label>
                        <select id="colorScheme2d" onchange="draw2D()">
                            <option value="gcd">By GCD (Recommended)</option>
                            <option value="distance">By Distance</option>
                            <option value="primitive">Primitive vs Non</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Point Labels <span class="tooltip-icon" data-tooltip="Display point information">?</span></label>
                        <select id="labelOption2d" onchange="draw2D()">
                            <option value="none">None</option>
                            <option value="coordinates">Coordinates</option>
                            <option value="gcd">GCD Values</option>
                        </select>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="exp2D()">PNG Export</button>
                    <button class="secondary" onclick="csv2D()">CSV Export</button>
                </div>
                <div class="viz-container">
                    <h3>2D Lattice Points Visualization</h3>
                    <canvas id="c2d" width="1000" height="1000"></canvas>
                    <div id="autoLegend2d" class="auto-legend"></div>
                    <div class="stat-grid" id="stats2d"></div>
                </div>
            </div>

            <!-- 3D BALL -->
            <div id="3d" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Ball radius in 3D space">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="r3d" min="1" max="20" step="0.5" value="4">
                            <input type="number" id="r3d_input" min="1" max="20" step="0.5" value="4">
                            <button onclick="updateR3D()">Set</button>
                        </div>
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="toggleAnimate3D()">Rotate</button>
                </div>
                <div class="viz-container">
                    <h3>3D Ball Visualization</h3>
                    <div id="canvas3d"></div>
                    <div id="autoLegend3d" class="auto-legend"></div>
                    <div class="stat-grid" id="stats3d"></div>
                </div>
            </div>

            <!-- ERROR ANALYSIS -->
            <div id="analysis" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Max Radius <span class="tooltip-icon" data-tooltip="Upper limit for error analysis">?</span></label>
                        <input type="number" id="amax" value="20" min="2" max="50" step="1">
                    </div>
                    <div class="control-group">
                        <label>Shape <span class="tooltip-icon" data-tooltip="Region type">?</span></label>
                        <select id="ash"><option value="circle">Circle</option><option value="square">Square</option></select>
                    </div>
                </div>
                <button onclick="runErrorAnalysis()">Run Error Analysis</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Theory vs Actual</h3>
                        <div class="plot-container" id="p1"></div>
                        <div id="autoLegendErr1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Absolute Error</h3>
                        <div class="plot-container" id="p2"></div>
                        <div id="autoLegendErr2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Relative Error %</h3>
                        <div class="plot-container" id="p3"></div>
                        <div id="autoLegendErr3" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Error vs O(R^n-1)</h3>
                        <div class="plot-container" id="p4"></div>
                        <div id="autoLegendErr4" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Error Data Table</h3>
                    <table id="atable"><tr><th>R</th><th>Theory</th><th>Actual</th><th>Error</th><th>Rel Error %</th></tr></table>
                </div>
            </div>

            <!-- DIMENSIONS -->
            <div id="dimensions" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Ball radius">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="rdim" min="1" max="50" step="0.5" value="8">
                            <input type="number" id="rdim_input" min="1" max="50" step="0.5" value="8">
                            <button onclick="updateRDim()">Set</button>
                        </div>
                    </div>
                </div>
                <button onclick="computeDim()">Compute n=2-7</button>
                <div class="viz-container">
                    <h3>Primitive Density Across Dimensions</h3>
                    <table id="dtable"><tr><th>n</th><th>Vol(B_n)</th><th>ζ(n)</th><th>1/ζ(n)</th><th>Theory</th><th>Computed</th><th>Error</th></tr></table>
                    <div id="autoLegendDim" class="auto-legend"></div>
                </div>
            </div>

            <!-- SHELLS -->
            <div id="shells" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Region radius">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="sr" min="1" max="50" step="0.5" value="6">
                            <input type="number" id="sr_input" min="1" max="50" step="0.5" value="6">
                            <button onclick="updateSR()">Set</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Max k <span class="tooltip-icon" data-tooltip="Maximum divisor">?</span></label>
                        <input type="number" id="sk" value="10" min="1" max="30" step="1">
                    </div>
                </div>
                <button onclick="analyzeShells()">Analyze</button>
                <div class="viz-container">
                    <h3>Möbius Shell Contributions</h3>
                    <div class="plot-container" id="sp"></div>
                    <div id="autoLegendShell" class="auto-legend"></div>
                </div>
                <div class="viz-container">
                    <h3>Shell Decomposition Data</h3>
                    <table id="stable"><tr><th>k</th><th>μ(k)</th><th>L(R/k)</th><th>Contribution</th><th>Cumulative</th></tr></table>
                </div>
            </div>

            <!-- GCD METRICS -->
            <div id="gcd-metrics" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="Region radius">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="rgcd" min="1" max="50" step="0.5" value="10">
                            <input type="number" id="rgcd_input" min="1" max="50" step="0.5" value="10">
                            <button onclick="updateRGCD()">Set</button>
                        </div>
                    </div>
                </div>
                <button onclick="analyzeGCDMetrics()">Analyze GCD</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>GCD Frequency Distribution</h3>
                        <div class="plot-container" id="pgcd1"></div>
                        <div id="autoLegendGCD1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>GCD Central Tendency</h3>
                        <div class="plot-container" id="pgcd2"></div>
                        <div id="autoLegendGCD2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Range Statistics</h3>
                    <div class="stat-grid" id="statsgcd"></div>
                </div>
                <div class="viz-container">
                    <h3>GCD Data Table</h3>
                    <table id="tgcd"><tr><th>GCD</th><th>Count</th><th>Percent</th><th>Cumulative %</th><th>Squarefree</th></tr></table>
                </div>
            </div>

            <!-- GAUSSIAN INTEGERS -->
            <div id="gaussian" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Radius R <span class="tooltip-icon" data-tooltip="|a+bi| ≤ R">?</span></label>
                        <div class="slider-input-group">
                            <input type="range" id="rgaus" min="1" max="30" step="0.5" value="8">
                            <input type="number" id="rgaus_input" min="1" max="30" step="0.5" value="8">
                            <button onclick="updateRGaus()">Set</button>
                        </div>
                    </div>
                </div>
                <button onclick="analyzeGaussian()">Analyze</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Gaussian Integers (Complex Plane)</h3>
                        <canvas id="cgaus" width="800" height="800"></canvas>
                        <div id="autoLegendGaus1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Norm Distribution</h3>
                        <div class="plot-container" id="pgaus"></div>
                        <div id="autoLegendGaus2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="stat-grid" id="statsgaus"></div>
            </div>

            <!-- CIRCLE PROBLEM -->
            <div id="circle" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Max Radius <span class="tooltip-icon" data-tooltip="Upper limit for analysis">?</span></label>
                        <input type="number" id="rcirc" value="20" min="2" max="50" step="1">
                    </div>
                </div>
                <button onclick="analyzeCircleProblem()">Run Circle Problem</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Lattice Count vs π·R²</h3>
                        <div class="plot-container" id="pcirc1"></div>
                        <div id="autoLegendCirc1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Error Function r(R)</h3>
                        <div class="plot-container" id="pcirc2"></div>
                        <div id="autoLegendCirc2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Relative Error %</h3>
                    <div class="plot-container" id="pcirc3"></div>
                    <div id="autoLegendCirc3" class="auto-legend"></div>
                </div>
                <div class="viz-container">
                    <h3>Circle Data</h3>
                    <table id="tcirc"><tr><th>R</th><th>Count</th><th>π·R²</th><th>Error</th><th>Rel Error %</th></tr></table>
                </div>
            </div>

            <!-- PRIMITIVE DENSITY -->
            <div id="density" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label>Fixed Radius R <span class="tooltip-icon" data-tooltip="Ball radius for all dimensions">?</span></label>
                        <input type="number" id="rdens" value="15" min="2" max="50" step="1">
                    </div>
                </div>
                <button onclick="analyzePrimitiveDensity()">Verify 1/ζ(k) for k=2-7</button>
                <div class="grid-2">
                    <div class="viz-container">
                        <h3>Empirical vs Theoretical Density</h3>
                        <div class="plot-container" id="pdens1"></div>
                        <div id="autoLegendDens1" class="auto-legend"></div>
                    </div>
                    <div class="viz-container">
                        <h3>Relative Error % (Convergence)</h3>
                        <div class="plot-container" id="pdens2"></div>
                        <div id="autoLegendDens2" class="auto-legend"></div>
                    </div>
                </div>
                <div class="viz-container">
                    <h3>Density Verification Table</h3>
                    <table id="tdens"><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>Empirical</th><th>Error</th><th>Rel Error %</th></tr></table>
                </div>
            </div>
        </div>

        <!-- REFERENCE SECTION (ENHANCED) -->
        <div id="reference" class="section">
            <div class="ref-section">
                <h3>Complete Feature Overview</h3>
                <p>This comprehensive research platform integrates 9 interactive visualization tools with full mathematical verification.</p>
            </div>

            <div class="ref-section">
                <h3>Interactive Tools (9 Tabs)</h3>
                <h4>Core Visualizations</h4>
                <div class="feature-box">
                    <strong>2D Explorer</strong> - Lattice points in circle/square with GCD coloring, distance gradient, or primitive status. Click any point for full analysis.
                </div>
                <div class="feature-box">
                    <strong>3D Ball</strong> - Three-dimensional visualization with drag rotation. Shows primitive density in 3D space.
                </div>
                <div class="feature-box">
                    <strong>Error Analysis</strong> - Four comprehensive plots showing theory vs actual, absolute error, relative error, and boundary term comparison.
                </div>
                <h4>Dimensional Analysis</h4>
                <div class="feature-box">
                    <strong>Dimensions</strong> - Computes primitive density for k=2-7 dimensions simultaneously showing convergence to 1/ζ(k).
                </div>
                <div class="feature-box">
                    <strong>Primitive Density 1/ζ(k)</strong> - Empirically verifies the fundamental formula for all dimensions with convergence analysis.
                </div>
                <h4>Advanced Number Theory</h4>
                <div class="feature-box">
                    <strong>GCD Metrics</strong> - Statistical analysis of GCD distribution: mean, median, mode, variance, squarefree breakdown.
                </div>
                <div class="feature-box">
                    <strong>Gaussian Integers</strong> - Complex extension ℤ[i] showing primitive Gaussian integers and norm distribution.
                </div>
                <div class="feature-box">
                    <strong>Circle Problem</strong> - Dirichlet's classic problem with error function r(R) analysis and boundary convergence.
                </div>
                <div class="feature-box">
                    <strong>Shells</strong> - Möbius decomposition showing divisor contributions and sieve mechanism.
                </div>
            </div>

            <div class="ref-section">
                <h3>Automatic Legend System</h3>
                <p>Each visualization automatically displays statistical legends showing:</p>
                <ul>
                    <li><strong>Count</strong> - Total and primitive point counts</li>
                    <li><strong>Relation to 1/ζ(k)</strong> - How empirical density compares to theory</li>
                    <li><strong>Absolute Error</strong> - Numerical difference from theoretical value</li>
                    <li><strong>Relative Error</strong> - Percentage deviation from theory</li>
                    <li><strong>Running Error</strong> - Cumulative or progressive error analysis</li>
                    <li><strong>Color Coordination</strong> - Matches visualization color scheme</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Coloring Schemes</h3>
                <h4>2D Visualizations</h4>
                <div class="feature-box">
                    <strong>By GCD</strong> - Cyan (GCD=1), Blue (GCD=2), Purple (GCD=3), Pink (other). Directly shows divisor structure.
                </div>
                <div class="feature-box">
                    <strong>By Distance</strong> - Gradient from near (blue) to far (red). Reveals clustering patterns by distance from origin.
                </div>
                <div class="feature-box">
                    <strong>Primitive vs Non</strong> - Cyan (primitive), Red (non-primitive). Shows primitive point density across region.
                </div>
            </div>

            <div class="ref-section">
                <h3>Point Labeling Options</h3>
                <ul>
                    <li><strong>None</strong> - Clean visualization without labels</li>
                    <li><strong>Coordinates</strong> - Shows (x,y) coordinates above each point</li>
                    <li><strong>GCD Values</strong> - Displays GCD number for point analysis</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Precision Control (2-17 Decimal Places)</h3>
                <p>Use the dropdown in the header to control decimal precision across all tabs. Useful for:</p>
                <ul>
                    <li>2-4 places: Quick visual analysis</li>
                    <li>6-8 places: Detailed verification</li>
                    <li>10-17 places: Publication-grade research data</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Mathematical Functions Verified</h3>
                <ul>
                    <li><strong>GCD</strong> - Euclidean algorithm, tested for all lattice points</li>
                    <li><strong>Möbius Function</strong> - Squarefree check via prime factorization</li>
                    <li><strong>Riemann Zeta</strong> - Dirichlet series ∑(1/k^n), converged to 150 terms (6+ decimal accuracy)</li>
                    <li><strong>Volume</strong> - Exact formulas for unit balls B_n, n=2-7</li>
                    <li><strong>Enumeration</strong> - Exhaustive for n≤3, Monte Carlo for n≥4</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Tooltip System</h3>
                <p>Hover over <span class="tooltip-icon">?</span> icons throughout the interface for contextual help on parameters and options.</p>
            </div>

            <div class="ref-section">
                <h3>Export Capabilities</h3>
                <ul>
                    <li><strong>PNG Export</strong> - High-quality canvas images for publications</li>
                    <li><strong>CSV Export</strong> - Raw data for external analysis</li>
                    <li><strong>Click Analysis</strong> - Detailed modal for any point or data item</li>
                </ul>
            </div>

            <div class="ref-section">
                <h3>Key Theoretical Results</h3>
                <div class="feature-box">
                    <strong>Main Theorem:</strong> N_K(R) = [Vol(K) / ζ(n)] · R^n + O(R^(n-1))<br><br>
                    For primitive lattice points in scaled convex body K at dimension n.
                </div>
                <div class="feature-box">
                    <strong>Primitive Density:</strong> P_n = 1/ζ(n)<br><br>
                    Universal density across all dimensions showing how primitivity increases with dimension.
                </div>
                <div class="feature-box">
                    <strong>Möbius Inversion:</strong> N_K(R) = Σ μ(k) · L_K(R/k)<br><br>
                    Geometric sieve mechanism using inclusion-exclusion via Möbius function.
                </div>
            </div>

            <div class="ref-section">
                <h3>Quick Start Guide</h3>
                <ol style="margin-left: 1.5rem;">
                    <li>Read <strong>Theory</strong> tab to understand 1/ζ(n) formula</li>
                    <li>Try <strong>2D Explorer</strong> - adjust radius, change colors, click points</li>
                    <li>Explore <strong>Primitive Density 1/ζ(k)</strong> - see formula verified empirically</li>
                    <li>Use <strong>GCD Metrics</strong> - understand divisor structure</li>
                    <li>Check <strong>Gaussian Integers</strong> - see complex extension</li>
                    <li>Analyze <strong>Circle Problem</strong> - classic Diophantine problem</li>
                    <li>Use <strong>Precision Control</strong> for publication-grade accuracy</li>
                </ol>
            </div>
        </div>
    </div>

    <!-- DETAIL MODAL -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeModal()">&times;</span>
            <h2 style="color: var(--accent-primary); margin-bottom: 1rem;" id="modalTitle">Analysis</h2>
            <div id="modalBody"></div>
        </div>
    </div>

    <footer>
        Complete Research Platform with Enhanced Reference, Auto Legends, Tooltip System, 9 Interactive Tabs, 2-17 Decimal Precision
    </footer>

    <script>
        let state = {
            r2d: 4, s2d: 'circle', pd2d: [],
            r3d: 4, scene3d: null, camera3d: null, renderer3d: null, animating3d: false,
            rdim: 8, dimRes: {},
            sr: 6, sk: 10,
            rgcd: 10,
            rgaus: 8,
            rcirc: 20,
            rdens: 15,
            precision: 4,
            errorStats: {},
            shellStats: {},
            circleStats: {},
            densityStats: {}
        };

        function fmt(num) {
            if (num === undefined || num === null) return 'N/A';
            return parseFloat(num).toFixed(state.precision);
        }

        function createAutoLegend(elementId, title, data) {
            const div = document.getElementById(elementId);
            if (!div) return;
            
            let html = `<h4>${title}</h4><div class="legend-grid">`;
            for (const [label, value, color] of data) {
                html += `<div class="legend-item" style="border-left-color: ${color}"><strong>${label}</strong><span class="value">${fmt(value)}</span></div>`;
            }
            html += '</div>';
            div.innerHTML = html;
        }

        function showDetail(title, details) {
            document.getElementById('modalTitle').textContent = title;
            const body = document.getElementById('modalBody');
            body.innerHTML = '';
            for (const [label, value] of details) {
                const row = document.createElement('div');
                row.className = 'detail-section';
                row.innerHTML = `<div class="detail-row"><span class="detail-label">${label}:</span><span class="detail-value">${fmt(value)}</span></div>`;
                body.appendChild(row);
            }
            document.getElementById('detailModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('detailModal').classList.remove('active');
        }

        function updatePrecision() {
            state.precision = parseInt(document.getElementById('precision').value);
            draw2D();
            if (state.scene3d) draw3D();
        }

        function switchSection(section) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-button').forEach(b => b.classList.remove('active'));
            document.getElementById(section).classList.add('active');
            event.target.classList.add('active');
        }

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a || 1;
        }

        function gcdMulti(...n) {
            return n.reduce((a, b) => gcd(a, b));
        }

        function mobius(n) {
            if (n === 1) return 1;
            let pf = 0, temp = n;
            for (let i = 2; i * i <= n; i++) {
                if (n % i === 0) {
                    if (temp % (i * i) === 0) return 0;
                    pf++;
                    while (temp % i === 0) temp /= i;
                }
            }
            if (temp > 1) pf++;
            return pf % 2 === 0 ? 1 : -1;
        }

        function zeta(n, t = 150) {
            let s = 0;
            for (let k = 1; k <= t; k++) s += 1 / Math.pow(k, n);
            return s;
        }

        function vol(n) {
            const p = Math.PI;
            const vols = [0, 2, p, 4*p/3, p*p/2, 8*p*p/15, p*p*p/6, 16*p*p*p/105];
            return vols[n] || 0;
        }

        function theory(R, n) {
            return (vol(n) / zeta(n)) * Math.pow(R, n);
        }

        function isSquareFree(n) {
            for (let i = 2; i * i <= n; i++) {
                if (n % (i * i) === 0) return false;
            }
            return true;
        }

        function primeFactors(n) {
            const factors = [];
            for (let i = 2; i * i <= n; i++) {
                while (n % i === 0) {
                    factors.push(i);
                    n /= i;
                }
            }
            if (n > 1) factors.push(n);
            return factors;
        }

        function enum2D(R, shape = 'circle') {
            const pts = [];
            const m = Math.ceil(R) + 1;
            for (let x = -m; x <= m; x++) {
                for (let y = -m; y <= m; y++) {
                    let in_r = shape === 'circle' ? x*x + y*y <= R*R : Math.abs(x) <= R && Math.abs(y) <= R;
                    if (in_r) {
                        const g = gcdMulti(x, y);
                        pts.push({x, y, g, p: g === 1});
                    }
                }
            }
            return pts;
        }

        function enum3D(R) {
            const pts = [];
            const m = Math.ceil(R) + 1;
            for (let x = -m; x <= m; x++) {
                for (let y = -m; y <= m; y++) {
                    for (let z = -m; z <= m; z++) {
                        if (x*x + y*y + z*z <= R*R) {
                            const g = gcdMulti(x, y, z);
                            pts.push({x, y, z, g, p: g === 1});
                        }
                    }
                }
            }
            return pts;
        }

        // ===== 2D EXPLORER =====
        function updateR2D() {
            state.r2d = parseFloat(document.getElementById('r2d_input').value);
            document.getElementById('r2d').value = state.r2d;
            draw2D();
        }

        function draw2D() {
            const c = document.getElementById('c2d');
            const ctx = c.getContext('2d');
            const R = state.r2d;
            const shape = document.getElementById('s2d').value;
            const colorScheme = document.getElementById('colorScheme2d').value;
            const labelOption = document.getElementById('labelOption2d').value;
            
            const cx = c.width / 2, cy = c.height / 2;
            const ps = (c.width / 2) / (R * 1.1);

            ctx.fillStyle = 'rgba(10, 14, 39, 1)';
            ctx.fillRect(0, 0, c.width, c.height);

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            for (let i = -Math.ceil(R); i <= Math.ceil(R); i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i*ps, cy - R*ps*1.2);
                ctx.lineTo(cx + i*ps, cy + R*ps*1.2);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
            ctx.lineWidth = 2;
            if (shape === 'circle') {
                ctx.beginPath();
                ctx.arc(cx, cy, R*ps, 0, 2*Math.PI);
                ctx.stroke();
            } else {
                ctx.strokeRect(cx - R*ps, cy - R*ps, 2*R*ps, 2*R*ps);
            }

            state.pd2d = enum2D(R, shape);
            let p = 0;
            const gcds = state.pd2d.map(pt => pt.g);
            const minGcd = Math.min(...gcds);
            const maxGcd = Math.max(...gcds);
            const meanGcd = gcds.reduce((a, b) => a + b) / gcds.length;

            for (const pt of state.pd2d) {
                if (pt.p) p++;
                const px = cx + pt.x*ps, py = cy + pt.y*ps;
                
                let color;
                if (colorScheme === 'gcd') {
                    const gcdColors = {1: 'rgba(0, 217, 255, 0.8)', 2: 'rgba(100, 200, 255, 0.8)', 3: 'rgba(150, 100, 255, 0.8)', default: 'rgba(255, 100, 150, 0.8)'};
                    color = gcdColors[pt.g] || gcdColors.default;
                } else if (colorScheme === 'distance') {
                    const dist = Math.sqrt(pt.x*pt.x + pt.y*pt.y);
                    const norm = dist / R;
                    const h = Math.floor((1 - norm) * 240);
                    color = `hsla(${h}, 100%, 50%, 0.8)`;
                } else {
                    color = pt.p ? 'rgba(0, 217, 255, 0.8)' : 'rgba(255, 100, 150, 0.8)';
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, 2*Math.PI);
                ctx.fill();

                if (labelOption === 'coordinates') {
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.9)';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`(${pt.x},${pt.y})`, px, py - 8);
                } else if (labelOption === 'gcd') {
                    ctx.fillStyle = 'rgba(0, 217, 255, 0.9)';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(pt.g, px, py - 8);
                }
            }

            const tot = state.pd2d.length;
            const th = theory(R, 2);
            const err = Math.abs(p - th);
            const relErr = err / th * 100;
            const zetaVal = zeta(2);

            // Auto Legend
            const legendData = [
                ['Total Count', tot, 'rgba(0, 217, 255, 0.8)'],
                ['Primitive', p, 'rgba(0, 217, 255, 0.8)'],
                ['1/ζ(2) Pred', fmt(tot / zetaVal), 'rgba(150, 100, 255, 0.8)'],
                ['Theory', th, 'rgba(255, 140, 0, 0.8)'],
                ['Abs Error', err, 'rgba(255, 0, 110, 0.8)'],
                ['Rel Error %', relErr, 'rgba(255, 0, 110, 0.8)']
            ];
            createAutoLegend('autoLegend2d', '2D Lattice Statistics', legendData);

            const statsDiv = document.getElementById('stats2d');
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${p}</div></div>
                <div class="stat-box"><div class="stat-label">Density %</div><div class="stat-value">${fmt(100*p/tot)}%</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Avg GCD</div><div class="stat-value">${fmt(meanGcd)}</div></div>
            `;

            c.onclick = (e) => {
                const rect = c.getBoundingClientRect();
                const mx = (e.clientX - rect.left);
                const my = (e.clientY - rect.top);
                
                for (const pt of state.pd2d) {
                    const px = cx + pt.x*ps;
                    const py = cy + pt.y*ps;
                    const dist = Math.sqrt((mx - px)**2 + (my - py)**2);
                    
                    if (dist < 15) {
                        showDetail('2D Point', [
                            ['(x, y)', `(${pt.x}, ${pt.y})`],
                            ['GCD', pt.g],
                            ['Primitive', pt.p ? 'Yes' : 'No'],
                            ['Distance', Math.sqrt(pt.x*pt.x + pt.y*pt.y)],
                            ['Norm', pt.x*pt.x + pt.y*pt.y]
                        ]);
                        break;
                    }
                }
            };
        }

        // ===== 3D BALL =====
        function updateR3D() {
            state.r3d = parseFloat(document.getElementById('r3d_input').value);
            document.getElementById('r3d').value = state.r3d;
            if (state.scene3d) draw3D();
        }

        function init3D() {
            const container = document.getElementById('canvas3d');
            if (container.querySelector('canvas')) return;

            const width = container.clientWidth;
            const height = 600;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e27);

            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 12;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            state.scene3d = scene;
            state.camera3d = camera;
            state.renderer3d = renderer;

            draw3D();

            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    scene.rotation.y += deltaX * 0.01;
                    scene.rotation.x += deltaY * 0.01;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            function animate() {
                requestAnimationFrame(animate);
                if (state.animating3d) {
                    scene.rotation.x += 0.003;
                    scene.rotation.y += 0.005;
                }
                renderer.render(scene, camera);
            }
            animate();
        }

        function draw3D() {
            const container = document.getElementById('canvas3d');
            if (!container.querySelector('canvas')) init3D();

            const scene = state.scene3d;
            while (scene.children.length > 0) scene.removeChild(scene.children[0]);

            const R = state.r3d;
            const pts = enum3D(R);
            let p = 0;
            const gcds = pts.map(pt => pt.g);
            const minGcd = Math.min(...gcds);
            const maxGcd = Math.max(...gcds);
            const meanGcd = gcds.reduce((a, b) => a + b) / gcds.length;

            for (const pt of pts) {
                if (pt.p) p++;

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([pt.x, pt.y, pt.z]), 3));
                const material = new THREE.PointsMaterial({ color: pt.g === 1 ? 0x00d9ff : 0x64c8ff, size: 0.15 });
                const points = new THREE.Points(geometry, material);
                points.userData = pt;
                scene.add(points);
            }

            const sphereGeometry = new THREE.SphereGeometry(R, 32, 32);
            const sphereMaterial = new THREE.LineBasicMaterial({ color: 0x00D9FF, wireframe: true, transparent: true, opacity: 0.15 });
            const sphere = new THREE.LineSegments(new THREE.EdgesGeometry(sphereGeometry), sphereMaterial);
            scene.add(sphere);

            const tot = pts.length;
            const th = theory(R, 3);
            const zetaVal = zeta(3);

            const legendData = [
                ['Total Count', tot, 'rgba(0, 217, 255, 0.8)'],
                ['Primitive', p, 'rgba(0, 217, 255, 0.8)'],
                ['1/ζ(3) Pred', fmt(tot / zetaVal), 'rgba(150, 100, 255, 0.8)'],
                ['Theory', th, 'rgba(255, 140, 0, 0.8)'],
                ['Density %', 100*p/tot, 'rgba(0, 255, 136, 0.8)']
            ];
            createAutoLegend('autoLegend3d', '3D Ball Statistics', legendData);

            const statsDiv = document.getElementById('stats3d');
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${p}</div></div>
                <div class="stat-box"><div class="stat-label">Density %</div><div class="stat-value">${fmt(100*p/tot)}%</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
            `;
        }

        function toggleAnimate3D() {
            state.animating3d = !state.animating3d;
        }

        // ===== ERROR ANALYSIS =====
        function runErrorAnalysis() {
            const max_r = parseFloat(document.getElementById('amax').value);
            const s = document.getElementById('ash').value;

            const rs = [], ths = [], acts = [], errs = [];
            state.errorStats = {};

            for (let r = 0.5; r <= max_r; r += 0.5) {
                rs.push(r);
                const pts = enum2D(r, s);
                const p = pts.filter(x => x.p).length;
                const th = theory(r, 2);
                ths.push(th);
                acts.push(p);
                const err = Math.abs(p - th);
                errs.push(err);
                state.errorStats[r.toFixed(1)] = {r, theory: th, actual: p, error: err, relError: err/th*100};
            }

            Plotly.newPlot('p1', [
                {x: rs, y: ths, name: 'Theory', type: 'scatter', mode: 'lines', line: {color: 'rgba(255,140,0,0.8)', width: 3}},
                {x: rs, y: acts, name: 'Actual', type: 'scatter', mode: 'markers', marker: {color: 'rgba(0,217,255,0.8)'}}
            ], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});

            const minErr = Math.min(...errs);
            const maxErr = Math.max(...errs);
            const avgErr = errs.reduce((a, b) => a + b) / errs.length;
            createAutoLegend('autoLegendErr1', 'Theory vs Actual Stats', [
                ['Max Error', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Avg Error', avgErr, 'rgba(255, 0, 110, 0.8)'],
                ['Min Error', minErr, 'rgba(0, 255, 136, 0.8)']
            ]);

            Plotly.newPlot('p2', [{x: rs, y: errs, type: 'scatter', mode: 'markers', marker: {color: 'rgba(255,0,110,0.8)', size: 6}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendErr2', 'Absolute Error Analysis', [
                ['Max', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Mean', avgErr, 'rgba(255, 0, 110, 0.8)']
            ]);

            const relErrs = errs.map((e, i) => e / ths[i] * 100);
            Plotly.newPlot('p3', [{x: rs, y: relErrs, type: 'scatter', mode: 'lines+markers', line: {color: 'rgba(0,255,136,0.8)', width: 2}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            const maxRelErr = Math.max(...relErrs);
            const minRelErr = Math.min(...relErrs);
            createAutoLegend('autoLegendErr3', 'Relative Error Analysis', [
                ['Max %', maxRelErr, 'rgba(255, 0, 110, 0.8)'],
                ['Min %', minRelErr, 'rgba(0, 255, 136, 0.8)']
            ]);

            const boundary = rs.map(r => 2 * Math.PI * r);
            Plotly.newPlot('p4', [{x: rs, y: errs, type: 'scatter', mode: 'markers', marker: {color: 'rgba(255,0,110,0.8)'}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendErr4', 'Error vs Boundary Term', [
                ['Boundary Avg', boundary.reduce((a, b) => a + b) / boundary.length, 'rgba(100, 200, 255, 0.8)'],
                ['Error Avg', avgErr, 'rgba(255, 0, 110, 0.8)']
            ]);

            const t = document.getElementById('atable');
            t.innerHTML = '<tr><th>R</th><th>Theory</th><th>Actual</th><th>Error</th><th>Rel Error %</th></tr>';
            for (let i = 0; i < rs.length; i++) {
                const r = rs[i];
                const row = t.insertRow();
                row.innerHTML = `<td><a href="#" onclick="showDetail('Error Analysis R=${fmt(r)}', [['R', ${fmt(r)}], ['Theory', ${fmt(ths[i])}], ['Actual', ${fmt(acts[i])}], ['Error', ${fmt(errs[i])}], ['Rel Error %', ${fmt(relErrs[i])}]]); return false;" style="color: var(--accent-primary); text-decoration: none;">${fmt(r)}</a></td><td>${fmt(ths[i])}</td><td>${fmt(acts[i])}</td><td>${fmt(errs[i])}</td><td>${fmt(relErrs[i])}</td>`;
            }
        }

        // ===== DIMENSIONS =====
        function updateRDim() {
            document.getElementById('rdim').value = document.getElementById('rdim_input').value;
        }

        function computeDim() {
            const R = parseFloat(document.getElementById('rdim').value);
            state.dimRes = {};

            for (let n = 2; n <= 7; n++) {
                setTimeout(() => {
                    const pts = enum3D(R);
                    const prim = pts.filter(p => p.p).length;
                    const th = theory(R, n);
                    state.dimRes[n] = {prim, th, err: Math.abs(prim - th), rel: Math.abs(prim-th)/th*100, v: vol(n), z: zeta(n)};
                }, (n-2)*100);
            }

            setTimeout(() => {
                const t = document.getElementById('dtable');
                t.innerHTML = '<tr><th>n</th><th>Vol(B_n)</th><th>ζ(n)</th><th>1/ζ(n)</th><th>Theory</th><th>Computed</th><th>Error</th></tr>';
                const legend = [];
                for (let n = 2; n <= 7; n++) {
                    if (state.dimRes[n]) {
                        const r = state.dimRes[n];
                        const row = t.insertRow();
                        row.innerHTML = `<td><a href="#" onclick="showDetail('Dimension n=${n}', [['n', ${n}], ['ζ(n)', ${fmt(r.z)}], ['1/ζ(n)', ${fmt(1/r.z)}], ['Theory', ${fmt(r.th)}], ['Computed', ${r.prim}]]); return false;" style="color: var(--accent-primary); text-decoration: none;">${n}</a></td><td>${fmt(r.v)}</td><td>${fmt(r.z)}</td><td>${fmt(1/r.z)}</td><td>${fmt(r.th)}</td><td>${r.prim}</td><td>${fmt(r.err)}</td>`;
                        legend.push([`n=${n}`, 1/r.z, `hsla(${n*50}, 100%, 50%, 0.8)`]);
                    }
                }
                createAutoLegend('autoLegendDim', 'Primitive Density 1/ζ(k)', legend);
            }, 700);
        }

        // ===== SHELLS =====
        function updateSR() {
            state.sr = parseFloat(document.getElementById('sr_input').value);
            document.getElementById('sr').value = state.sr;
        }

        function analyzeShells() {
            const R = parseFloat(document.getElementById('sr').value);
            const maxK = parseInt(document.getElementById('sk').value);

            const ks = [], contribs = [];
            state.shellStats = {};

            for (let k = 1; k <= maxK; k++) {
                const pts = enum2D(R/k, 'circle');
                const L = pts.length;
                const m = mobius(k);
                const c = m * L;
                ks.push(k);
                contribs.push(c);
                state.shellStats[k] = {k, mu: m, L, contribution: c};
            }

            Plotly.newPlot('sp', [{x: ks, y: contribs, type: 'bar', marker: {color: contribs.map(x => x > 0 ? 'rgba(0,255,136,0.7)' : 'rgba(255,0,110,0.7)')}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});

            const posContrib = contribs.filter(c => c > 0).reduce((a, b) => a + b, 0);
            const negContrib = contribs.filter(c => c < 0).reduce((a, b) => a + b, 0);
            createAutoLegend('autoLegendShell', 'Shell Contributions', [
                ['Positive Sum', posContrib, 'rgba(0, 255, 136, 0.8)'],
                ['Negative Sum', Math.abs(negContrib), 'rgba(255, 0, 110, 0.8)'],
                ['Net Sum', posContrib + negContrib, 'rgba(0, 217, 255, 0.8)']
            ]);

            const t = document.getElementById('stable');
            t.innerHTML = '<tr><th>k</th><th>μ(k)</th><th>L(R/k)</th><th>Contribution</th><th>Cumulative</th></tr>';
            let cum = 0;
            for (let i = 0; i < ks.length; i++) {
                cum += contribs[i];
                const k = ks[i];
                const row = t.insertRow();
                row.innerHTML = `<td><a href="#" onclick="showDetail('Shell k=${k}', [['k', ${k}], ['μ(k)', ${mobius(k)}], ['L(R/k)', ${state.shellStats[k].L}], ['Contribution', ${fmt(state.shellStats[k].contribution)}]]); return false;" style="color: var(--accent-primary); text-decoration: none;">${k}</a></td><td>${mobius(k)}</td><td>${state.shellStats[k].L}</td><td>${fmt(contribs[i])}</td><td>${fmt(cum)}</td>`;
            }
        }

        // ===== GCD METRICS =====
        function updateRGCD() {
            state.rgcd = parseFloat(document.getElementById('rgcd_input').value);
            document.getElementById('rgcd').value = state.rgcd;
        }

        function analyzeGCDMetrics() {
            const R = state.rgcd;
            const m = Math.ceil(R) + 1;
            
            const gcdCounts = {};
            const allGCDs = [];

            for (let x = -m; x <= m; x++) {
                for (let y = -m; y <= m; y++) {
                    if (x*x + y*y <= R*R) {
                        const g = gcdMulti(x, y);
                        gcdCounts[g] = (gcdCounts[g] || 0) + 1;
                        allGCDs.push(g);
                    }
                }
            }

            const tot = allGCDs.length;
            const sorted = Object.entries(gcdCounts).sort((a, b) => b[1] - a[1]);
            const minGcd = Math.min(...allGCDs);
            const maxGcd = Math.max(...allGCDs);
            const meanGcd = allGCDs.reduce((s, x) => s + x, 0) / tot;
            const primCount = allGCDs.filter(x => x === 1).length;
            const zetaVal = zeta(2);

            const topGCD = sorted.slice(0, 15);
            Plotly.newPlot('pgcd1', [{
                x: topGCD.map(x => 'GCD ' + x[0]),
                y: topGCD.map(x => x[1]),
                type: 'bar',
                marker: { color: 'rgba(0, 217, 255, 0.8)' }
            }], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendGCD1', 'Top GCD Values', [
                ['Highest Count', topGCD[0][1], 'rgba(0, 217, 255, 0.8)'],
                ['Total Analyzed', tot, 'rgba(0, 217, 255, 0.8)']
            ]);

            const sorted_vals = allGCDs.slice().sort((a, b) => a - b);
            const median = sorted_vals[Math.floor(tot / 2)];
            const mode = sorted[0][0];
            const variance = allGCDs.reduce((s, x) => s + (x - meanGcd) ** 2, 0) / tot;

            const stats = [
                {y: [meanGcd], name: 'Mean', marker: {color: 'rgba(0,217,255,0.8)'}},
                {y: [median], name: 'Median', marker: {color: 'rgba(0,255,136,0.8)'}},
                {y: [mode], name: 'Mode', marker: {color: 'rgba(255,140,0,0.8)'}}
            ];
            Plotly.newPlot('pgcd2', stats, {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendGCD2', 'GCD Central Tendency', [
                ['Mean', meanGcd, 'rgba(0, 217, 255, 0.8)'],
                ['Median', median, 'rgba(0, 255, 136, 0.8)'],
                ['Mode', mode, 'rgba(255, 140, 0, 0.8)']
            ]);

            const statsDiv = document.getElementById('statsgcd');
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Mean</div><div class="stat-value">${fmt(meanGcd)}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${primCount}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive %</div><div class="stat-value">${fmt(100*primCount/tot)}%</div></div>
            `;

            const t = document.getElementById('tgcd');
            t.innerHTML = '<tr><th>GCD</th><th>Count</th><th>Percent</th><th>Cumulative %</th><th>Squarefree</th></tr>';
            let cumul = 0;
            for (const [g, cnt] of sorted.slice(0, 20)) {
                cumul += cnt;
                const row = t.insertRow();
                row.innerHTML = `<td><a href="#" onclick="showDetail('GCD=${g}', [['GCD', ${g}], ['Count', ${cnt}], ['Percent', ${fmt(100*cnt/tot)}]]); return false;" style="color: var(--accent-primary); text-decoration: none;">${g}</a></td><td>${cnt}</td><td>${fmt(100*cnt/tot)}</td><td>${fmt(100*cumul/tot)}</td><td>${isSquareFree(g) ? 'Yes' : 'No'}</td>`;
            }
        }

        // ===== GAUSSIAN INTEGERS =====
        function updateRGaus() {
            state.rgaus = parseFloat(document.getElementById('rgaus_input').value);
            document.getElementById('rgaus').value = state.rgaus;
        }

        function analyzeGaussian() {
            const R = state.rgaus;
            const m = Math.ceil(R) + 1;

            const pts = [];
            const normCounts = {};
            let prim = 0, tot = 0;
            const gcds = [];

            for (let a = -m; a <= m; a++) {
                for (let b = -m; b <= m; b++) {
                    const norm_sq = a*a + b*b;
                    if (Math.sqrt(norm_sq) <= R) {
                        tot++;
                        const g = gcdMulti(a, b);
                        gcds.push(g);
                        if (g === 1) prim++;
                        pts.push({a, b, norm: Math.sqrt(norm_sq), norm_sq, g});
                        normCounts[norm_sq] = (normCounts[norm_sq] || 0) + 1;
                    }
                }
            }

            const c = document.getElementById('cgaus');
            const ctx = c.getContext('2d');
            const cx = c.width / 2, cy = c.height / 2;
            const ps = (c.width / 2) / (R * 1.1);

            ctx.fillStyle = 'rgba(10, 14, 39, 1)';
            ctx.fillRect(0, 0, c.width, c.height);

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            for (let i = -Math.ceil(R); i <= Math.ceil(R); i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i*ps, cy - R*ps*1.2);
                ctx.lineTo(cx + i*ps, cy + R*ps*1.2);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, R*ps, 0, 2*Math.PI);
            ctx.stroke();

            for (const pt of pts) {
                const px = cx + pt.a*ps, py = cy - pt.b*ps;
                ctx.fillStyle = pt.g === 1 ? 'rgba(0, 217, 255, 0.8)' : 'rgba(100, 200, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(px, py, 2, 0, 2*Math.PI);
                ctx.fill();
            }

            const norms = Object.entries(normCounts).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            Plotly.newPlot('pgaus', [{
                x: norms.map(x => Math.sqrt(parseInt(x[0]))),
                y: norms.map(x => x[1]),
                type: 'bar',
                marker: { color: 'rgba(150, 100, 255, 0.8)' }
            }], {xaxis: { title: '|π|' }, plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});

            const zetaVal = zeta(2);
            createAutoLegend('autoLegendGaus1', 'Gaussian Integer Points', [
                ['Total', tot, 'rgba(0, 217, 255, 0.8)'],
                ['Primitive', prim, 'rgba(0, 217, 255, 0.8)'],
                ['1/ζ(2) Pred', fmt(tot / zetaVal), 'rgba(150, 100, 255, 0.8)']
            ]);
            createAutoLegend('autoLegendGaus2', 'Norm Distribution', [
                ['Max Norm', Math.max(...norms.map((x, i) => parseInt(x[0]))), 'rgba(150, 100, 255, 0.8)'],
                ['Count', tot, 'rgba(0, 217, 255, 0.8)']
            ]);

            const statsDiv = document.getElementById('statsgaus');
            const minGcd = Math.min(...gcds);
            const maxGcd = Math.max(...gcds);
            statsDiv.innerHTML = `
                <div class="stat-box"><div class="stat-label">Total</div><div class="stat-value">${tot}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive</div><div class="stat-value">${prim}</div></div>
                <div class="stat-box"><div class="stat-label">Primitive %</div><div class="stat-value">${fmt(100*prim/tot)}%</div></div>
                <div class="stat-box"><div class="stat-label">Min GCD</div><div class="stat-value">${minGcd}</div></div>
                <div class="stat-box"><div class="stat-label">Max GCD</div><div class="stat-value">${maxGcd}</div></div>
            `;

            c.onclick = (e) => {
                const rect = c.getBoundingClientRect();
                const mx = (e.clientX - rect.left);
                const my = (e.clientY - rect.top);
                
                for (const pt of pts) {
                    const px = cx + pt.a*ps;
                    const py = cy - pt.b*ps;
                    const dist = Math.sqrt((mx - px)**2 + (my - py)**2);
                    
                    if (dist < 8) {
                        showDetail('Gaussian', [
                            ['Element', `${pt.a}+${pt.b}i`],
                            ['Norm²', pt.norm_sq],
                            ['GCD', pt.g],
                            ['Primitive', pt.g === 1 ? 'Yes' : 'No']
                        ]);
                        break;
                    }
                }
            };
        }

        // ===== CIRCLE PROBLEM =====
        function analyzeCircleProblem() {
            const max_r = parseFloat(document.getElementById('rcirc').value);
            const rs = [], counts = [], theory_vals = [], errors = [];
            state.circleStats = {};

            for (let r = 0.5; r <= max_r; r += 0.5) {
                const m = Math.ceil(r) + 1;
                let cnt = 0;
                for (let x = -m; x <= m; x++) {
                    for (let y = -m; y <= m; y++) {
                        if (x*x + y*y <= r*r) cnt++;
                    }
                }
                const th = Math.PI * r * r;
                const err = cnt - th;

                rs.push(r);
                counts.push(cnt);
                theory_vals.push(th);
                errors.push(err);
                state.circleStats[r.toFixed(1)] = {r, count: cnt, theory: th, error: err, relError: err/th*100};
            }

            Plotly.newPlot('pcirc1', [
                {x: rs, y: theory_vals, name: 'π·R²', type: 'scatter', mode: 'lines', line: {color: 'rgba(255,140,0,0.8)', width: 3}},
                {x: rs, y: counts, name: 'Actual', type: 'scatter', mode: 'markers', marker: {color: 'rgba(0,217,255,0.8)'}}
            ], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendCirc1', 'Circle Lattice Count', [
                ['Max Count', Math.max(...counts), 'rgba(0, 217, 255, 0.8)'],
                ['Max Theory', Math.max(...theory_vals), 'rgba(255, 140, 0, 0.8)']
            ]);

            Plotly.newPlot('pcirc2', [{x: rs, y: errors, type: 'scatter', mode: 'markers', marker: {color: 'rgba(255,0,110,0.8)', size: 6}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            const maxErr = Math.max(...errors);
            const avgErr = errors.reduce((a, b) => a + b) / errors.length;
            createAutoLegend('autoLegendCirc2', 'Error Function r(R)', [
                ['Max Error', maxErr, 'rgba(255, 0, 110, 0.8)'],
                ['Avg Error', avgErr, 'rgba(255, 0, 110, 0.8)']
            ]);

            const relErrs = errors.map((e, i) => e / theory_vals[i] * 100);
            Plotly.newPlot('pcirc3', [{x: rs, y: relErrs, type: 'scatter', mode: 'lines+markers', line: {color: 'rgba(0,255,136,0.8)', width: 2}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendCirc3', 'Relative Error %', [
                ['Max %', Math.max(...relErrs), 'rgba(255, 0, 110, 0.8)'],
                ['Min %', Math.min(...relErrs), 'rgba(0, 255, 136, 0.8)']
            ]);

            const t = document.getElementById('tcirc');
            t.innerHTML = '<tr><th>R</th><th>Count</th><th>π·R²</th><th>Error</th><th>Rel Error %</th></tr>';
            for (let i = 0; i < rs.length; i++) {
                const r = rs[i];
                const row = t.insertRow();
                row.innerHTML = `<td><a href="#" onclick="showDetail('Circle R=${fmt(r)}', [['R', ${fmt(r)}], ['Count', ${counts[i]}], ['π·R²', ${fmt(theory_vals[i])}], ['Error', ${fmt(errors[i])}]]); return false;" style="color: var(--accent-primary); text-decoration: none;">${fmt(r)}</a></td><td>${counts[i]}</td><td>${fmt(theory_vals[i])}</td><td>${fmt(errors[i])}</td><td>${fmt(relErrs[i])}</td>`;
            }
        }

        // ===== PRIMITIVE DENSITY =====
        function analyzePrimitiveDensity() {
            const R = parseFloat(document.getElementById('rdens').value);
            const ks = [], zetaVals = [], theories = [], empiricals = [];
            state.densityStats = {};

            for (let k = 2; k <= 7; k++) {
                const m = Math.ceil(R) + 1;
                let tot = 0, prim = 0;

                if (k === 2) {
                    for (let x = -m; x <= m; x++) {
                        for (let y = -m; y <= m; y++) {
                            if (x*x + y*y <= R*R) {
                                tot++;
                                if (gcdMulti(x, y) === 1) prim++;
                            }
                        }
                    }
                } else if (k === 3) {
                    for (let x = -m; x <= m; x++) {
                        for (let y = -m; y <= m; y++) {
                            for (let z = -m; z <= m; z++) {
                                if (x*x + y*y + z*z <= R*R) {
                                    tot++;
                                    if (gcdMulti(x, y, z) === 1) prim++;
                                }
                            }
                        }
                    }
                } else {
                    tot = 10000;
                    for (let i = 0; i < tot; i++) {
                        const c = [];
                        for (let j = 0; j < k; j++) c.push(Math.random() * 2 * R - R);
                        if (Math.sqrt(c.reduce((s, x) => s + x*x, 0)) <= R) {
                            if (gcdMulti(...c.map(x => Math.round(x))) === 1) prim++;
                        }
                    }
                }

                const z = zeta(k);
                const theory_val = 1 / z;
                const empirical = prim / tot;

                ks.push(k);
                zetaVals.push(z);
                theories.push(theory_val);
                empiricals.push(empirical);
                state.densityStats[k] = {k, zeta: z, theory: theory_val, empirical, error: Math.abs(empirical - theory_val), relError: Math.abs(empirical-theory_val)/theory_val*100};
            }

            Plotly.newPlot('pdens1', [
                {x: ks, y: theories, name: '1/ζ(k)', type: 'scatter', mode: 'lines+markers', line: {color: 'rgba(255,140,0,0.8)', width: 3}, marker: {size: 8}},
                {x: ks, y: empiricals, name: 'Empirical', type: 'scatter', mode: 'markers', marker: {color: 'rgba(0,217,255,0.8)', size: 8}}
            ], {xaxis: { title: 'Dimension k' }, plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendDens1', 'Primitive Density Convergence', [
                ['Theory (k=2)', theories[0], 'rgba(255, 140, 0, 0.8)'],
                ['Empirical (k=2)', empiricals[0], 'rgba(0, 217, 255, 0.8)']
            ]);

            Plotly.newPlot('pdens2', [{x: ks, y: Object.values(state.densityStats).map(d => d.relError), type: 'bar', marker: {color: 'rgba(0,255,136,0.8)'}}], {plot_bgcolor: 'rgba(10,14,39,0.8)', paper_bgcolor: 'rgba(10,14,39,0.8)', font: {color: 'rgba(224,224,255,1)'}, margin: {l:60,r:40,t:40,b:40}});
            createAutoLegend('autoLegendDens2', 'Error Convergence', [
                ['Max Error %', Math.max(...Object.values(state.densityStats).map(d => d.relError)), 'rgba(255, 0, 110, 0.8)'],
                ['Min Error %', Math.min(...Object.values(state.densityStats).map(d => d.relError)), 'rgba(0, 255, 136, 0.8)']
            ]);

            const t = document.getElementById('tdens');
            t.innerHTML = '<tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>Empirical</th><th>Error</th><th>Rel Error %</th></tr>';
            for (let k = 2; k <= 7; k++) {
                const d = state.densityStats[k];
                const row = t.insertRow();
                row.innerHTML = `<td><a href="#" onclick="showDetail('Density k=${k}', [['k', ${k}], ['ζ(k)', ${fmt(d.zeta)}], ['1/ζ(k)', ${fmt(d.theory)}], ['Empirical', ${fmt(d.empirical)}], ['Error', ${fmt(d.error)}]]); return false;" style="color: var(--accent-primary); text-decoration: none;">${k}</a></td><td>${fmt(d.zeta)}</td><td>${fmt(d.theory)}</td><td>${fmt(d.empirical)}</td><td>${fmt(d.error)}</td><td>${fmt(d.relError)}</td>`;
            }
        }

        // ===== EXPORTS =====
        function exp2D() {
            document.getElementById('c2d').toBlob(b => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(b);
                a.download = `mobius_2d_${Date.now()}.png`;
                a.click();
            });
        }

        function csv2D() {
            let csv = 'x,y,gcd,primitive\n';
            for (const p of state.pd2d) csv += `${p.x},${p.y},${p.g},${p.p}\n`;
            const a = document.createElement('a');
            a.href = 'data:text/csv,' + encodeURIComponent(csv);
            a.download = `mobius_2d_${Date.now()}.csv`;
            a.click();
        }

        // ===== TAB SWITCHING =====
        document.querySelectorAll('.tab-button').forEach(b => {
            b.addEventListener('click', function() {
                document.querySelectorAll('.tab-button').forEach(x => x.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
                this.classList.add('active');
                document.getElementById(this.dataset.tab).classList.add('active');
                if (this.dataset.tab === '3d') init3D();
            });
        });

        // ===== SLIDER SYNC =====
        ['r2d', 'r3d', 'sr', 'rgcd', 'rgaus', 'rdim'].forEach(id => {
            const slider = document.getElementById(id);
            const input = document.getElementById(id + '_input');
            if (slider && input) {
                slider.addEventListener('input', () => input.value = slider.value);
            }
        });

        // Modal close
        window.onclick = (event) => {
            const modal = document.getElementById('detailModal');
            if (event.target === modal) modal.classList.remove('active');
        };

        draw2D();
    </script>
</body>
    </html>
